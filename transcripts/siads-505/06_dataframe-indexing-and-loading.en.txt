In this course, we'll
largely be using smaller or
moderate-sized datasets. A common workflow is to
read the dataset in, usually from an external file, then begin to clean and manipulate the dataset
for analysis. In this lecture, I'm going to demonstrate how you can load data from a comma separated
file and into a DataFrame. Let's just jump right in and talk about comma-separated files. You've undoubtedly used these. Any Spreadsheet software like Excel or Google sheets can
save output in CSV format. It's a pretty loose as a format and it's
incredibly lightweight, and it's totally ubiquitous. Now, I'm going to make a quick aside because it's
convenient here. The Jupyter Notebooks use iPython as the kernel underneath which provides convenient ways to integrate lower-level
shell commands, which are programs run in the underlying operating system. If you're not familiar
with the shell, don't worry too much about this. But if you are, this
is super handy for integration of
your data science workflows. I want to use
one shell command here called cat' for concatenate, which just outputs
the contents of a file. In iPython, if we prepend the line with
an exclamation mark, it will execute the remainder of the line as a shell command. So let's look at that in
the contents of a CSV file. So I'll just type !cat datasets and I'll use the
admission_predictions.csv. We see from the output that
there's a list of columns, and that the column
identifiers are listed as strings on the first
line of the file. Then, we have rows of the data, all columns are
separated by commas. Now, there's lots of oddities
with the CSV file format, and there's no one agreed upon
specification or standard. So you should be prepared
to do a little bit of work when you pull down
CSV files to explore. But this lecture isn't
focused on CSV files per say, and is more about
Pandas DataFrames. So let's jump into
that. Let's bring in Pandas to work with. So I'll import Pandas as pd. Pandas makes it easy to turn
a CSV into a DataFrame. We just called
the read CSV function. So df equals pd.read_csv and we'll pass in datasets and
the Admission_Predict.csv. Note here we're not calling
anything on the DataFrame, we're calling it on
the Pandas module. And let's look at a few of the first rows,
that's just df.head. We notice that by default, the index starts with zero while the students serial numbers
starts from one. If you jump back
to the CSV output, you'll deduce the Pandas
has created a new index. Instead, we can set
the serial number as the index if we want to
by using the index call. So we can say df
equals pd.read_csv. We pass in our string to
our admissions predictions, then we pass in
a parameter index call, and we tell it which column
we're interested in. In this case, zero. Let's
print the head of that. Notice that we have two columns, SOP and LOR, and probably not everybody
knows what they mean. So let's change our column names
to make it more clear. In Pandas, we can use
the rename function. It takes a parameter
called columns, and we need to pass in a
dictionary which are the keys of the old column name and the value of the
corresponding new name. So I'll create
some new DataFrame variable, new_df and df.rename, and then I'll just inline pass in a dictionary for columns. So GRE score, we'll leave
it the same, TOEFL score, we'll leave it the same, university rating, we'll
leave it the same. Here's our statement of purpose, SOP and our LOR, letter
of recommendation. So we'll change those, we'll leave the cumulative GPA, and the research experience, and we'll leave the
chance of admit as well. So let's take a look
at this new DataFrame. From the output, we can see that only the SOP has
changed, but not LOR. So why is that? So let's investigate this a bit. First, we need to
make sure we've got all the column names correct. We can use the columns attribute of the DataFrame
to get a list. So we'll type new_df.columns. And I'll be honest, I often on the DataFrame call
this as a function, but it's not, it's an attribute. If we look closely at the output, we can see that there's
actually a space right after LOR and a space right
after chance of admit. So this is why
our renamed dictionary does not work for LOR because the key that we used is
just three characters instead of four
characters, LOR space. There's a couple of ways
that we could address this. One way would be
the change a column by including the space
in the new name. So the new_df equals
new_df.rename. And we pass in the
columns dictionary. Here we're just going to pass in the one that we want changed, so you don't have to pass
in the full dictionary each time LOR space and letter
of recommendation. Let's look at the head of that. So that works well, but it's a bit fragile. What if that was a tab instead
of a space or two spaces? Another way is to create some function that
does the cleaning, and then tell renamed to apply that function across
all of the data. Python comes with
a handy string function to strip white space
called strip. When we pass this into rename, we pass the function as
the mapper parameter, and then indicate whether
the axis should be the columns, or the index, that's
the row labels. So here's an example. So new_df equals new_df.rename. We pass in the mapper, and in this case we're passing in a reference to a function. So str.strip. We're not calling the function, we're just passing
a reference to that function, and Pandas will call it. We tell the axis that
we want it to call this on is across
the columns not rows. Now, let's take a look
at the results. So new_df.head. All right. Now, we've
got it. Both SOP and LOR had been renamed and chance
of admit has been trimmed up. Remember though that
the rename function isn't modifying the DataFrame. In this case, df is the
same as it always was. There's just a copy of new_df
with the change names. So if we do df.columns, we can see that those
still include our columns that are poorly named with
lots of extra white space. And I'll be honest, these white
spaces in column names, this is really common. You'll be doing this anytime
you're importing a CSV having to tweak
out extra white space. We can also use the df.columns
attribute by assigning it to a list of column names which will directly rename the columns. This will directly modify
the original DataFrame, and it's very efficient
especially when you have a lot of columns and you
only want to change a few. This technique is
also not affected by subtle errors in
the column names, a problem that we
just encountered. With a list, you could just
use the list index to change a certain value or use a list comprehension to
change all of the values. So as an example,
let's change all of the values of the column
names to lowercase. So first, we need
to get our lists. So I'll make some
new attribute calls, is equal to the list
of df.columns. So df.columns is actually
an indexing variable, and I just want to
convert it to a list. Then, I'm going to write
a little list comprehension. So I'll make calls
is equal to and then I start my list comprehension. And in there, I want to
say x.lower.strip. So I'm going to convert
X to lowercase, then call strip on it where x is a string and for x and calls. So we're just iterating
over everything in calls. Then, we just want
to overwrite what is already in the .columns
attributes. So df.columns equals calls, and then let's take
a look at our results. So df.head. In this lecture,
you've learned how to import a CSV file into a Pandas DataFrame object
and how to do some basic data manipulation
with the column names. The CSV file import mechanisms in Pandas have lots
of different options, and you really need to
learn these in order to be proficient at data manipulation. Once you've set up the format and change the shape of a DataFrame, you have a solid foundation to further actions such as conducting data analysis
and modeling. Now, there are other data
sources that you can load directly into DataFrames as
well including HTML webpages, databases, and
other file formats. But the CSV is by far the most common data format
you'll run into, and it's an important
one to know how to manipulate in Pandas.