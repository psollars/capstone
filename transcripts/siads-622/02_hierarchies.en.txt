All right, welcome back. We're going to start our adventure
through hierarchical data. And I want to give you
just a few more examples. Just to give you some appetite for
what we're going to see. And the problems that we're going to
encounter with this kind of data. So this is an example of a hierarchical
representation of basically an org chart. So this is the League of Nations and sort of the relationship of different
entities within the League of Nations. So you have people who manage
the highest level departments. And people who manage departments
under that and so on. So think of any sort of
corporate structure. There often is this kind of
hierarchical relationship. Where there's somebody at the top and
people under them and people under them and so on. So this is the more standard example
that probably you're familiar with. And if you work in a company,
this happens to be one for a sub department of
the University of Michigan. The cellular and
developmental biology department. Again, you can see the dean or
the department chair at the top and sort of people under them and so on. This is a very different representation. Same thing, it is hierarchical data. But it is a very different kind of data
set represented in a very different view. So this is called the Sunburst or
sometimes it's called an icicle diagram. When it's flattened out,
will show examples of that later. But this happens to be
a visualization of a library, specifically a visualization
library that is no longer used. But, it has the high level package names
in the middle and then lower level package names under that and so on,
up till the classes on the far edges. This one is interactive, so
you can click on things and will show examples of this later on. You can click to basically get additional
information as you go through. And to focus your attention
on different things. So hierarchical data sets. Hopefully, you have a sense of this
that basically can extend over a wide, wide array of different kinds of data that
we might be able to find out in the wild. so genealogies is like family histories,
animal kingdoms, organization charts, file organization, object oriented
programming and a zillion others. And we'll point you at
some resources later on. You can see other people in terms of what
they've tried to visualize in hierarchical fashion. So we went through this
a little bit before. But this is a hierarchical data set
that you're probably most familiar with. This is a standard tree diagram. And this is a visualization
that is a network and does not count as a hierarchy for
our purposes. However, this one does. So again, these are two different kinds
of hierarchical data sets that we will consider. One is more of a tree structure. The other is a dag
directed acyclic graph. So both of these are kind of legitimate
to consider under this framework. Because they have levels, right? So that's kind of a key feature of this,
is that we can think of containment. So node one contains node two
contains node three and so on. Like we can speak of the data in this way. Or we can talk about it as node one is
above node two is above node three and so on. So visualizing hierarchical data,
what are the different techniques. Node-link is kind of
the most standard approach. The node, probably even far from
the discussion, is one of these circles. So this is a node. The link is the edge between them. The root is the thing that we're
going to consider at the top. So sometimes there are natural roots. Or as you'll see in a second,
sometimes they're inferred. And the leaf is the node at the bottom. That does not have any children or does not have any sort of
sub lower connections. So the lowest level node
is considered a leaf. Okay, so this is the high level structure. This is a different diagram, where here, we've implied what the root is like. And assume, you're going to
have to make the inference, without any additional labelling. What you're probably going to infer
is, one of the nodes in here, the intersection of two edges,
is the root node. So that is a plausible root. But I haven't told you anything
about this visualisation. And so, it's possible that
this other node is a root. And so you have to give a little bit of
guidance to people when you're making visualizations of this type. Usually the thing in the middle
is considered the root or the kind of central node. But that's not always the case. And with interactivity, as you'll see
in a moment, that also goes away. Sometimes the root will move around
based on where you've moved the tree in the visualization. Alright, so in terms of tasks, thinking about sort of our layer cake of
domain abstraction technique and so on. There are different kinds of questions
that people ask of hierarchical data. So how much depth? How far down does it go in the hierarchy? How much fanning? So how many different cousins or
siblings there are in the tree? How far to nodes like, how far do we have
to go up and then down to reach a node? It would be, the domain
level problem might be: How far am I from somebody
else in a corporate org chart? So how far, how many steps away am I?
How many sub classes? So this is related to the fanning. How many different things are within that? How far down the hierarchy,
again related to the depth? Which sub tree contains an entity? So, often times we have
visualizations that involve search. So we're trying to target specific nodes. So we want to know which sub tree is going
to contain a specific node of interest. Think of trying to browse Wikipedia and
you're starting at the high level. You have a bunch of
categories underneath it. So which one do you pick to reach, finally, at the article of interest? So relatedly, which sub tree
contains the match to your query? Which sub tree contains other matching
items that are similar to yours and so on. So all these things are plausible
tasks within the high level definition of hierarchical data. In terms of techniques,
we're going to cover two main types. Okay, these are most of the things
that you will see in this space, although there will be lots of variants, will fall into either the tree
node link representations or what is called space filling. So space filling,
the most common type is called a tree map. And we'll explain how those work,
there are many variants of this. But these are basically the two
different types that we will encounter. What will become important,
this week and also next week is that. Because of the way
the data is structured and the way we need to lay out
these different things. So when we try and
figure out how to layout the tree. Or we try to compute sort of the optimal
space filling visualization. There's a lot of optimization
that has to happen. Because there is optimization,
not all algorithms are created equal. Some of them are very slow. Some of them have properties that
are undesirable for certain datasets. Like they'll make really ugly
visualizations if you feed in data sets that are distributed a certain way and
what not. And so, unlike in the past,
where we've sort of been able to kind of avoid dealing with
the specific algorithms, a bar chart's a bar chart like it doesn't matter which
algorithm is used to layout the bar chart, this is not the case for
both hierarchies and networks. And as you'll see for text as well. So the algorithms have different
properties in terms of dealing with excessive fan or depth issues. And I'll explain that in a second. But those are the two constraints that
drive different kinds of optimizations to happen. And produce very different
kinds of visualizations. Some will be good for certain tasks and
certain data distributions and will be awful for others. And so, you'll have to get a sense of, and
build a, kind of toolkit of all these different techniques
that you'll be able to leverage. And build off of to construct the right
visualization for the right task. So, in terms of layout, so just to get
into a little bit of the nitty gritty, just so you understand the problem
that we're going to experience, this is a standard tree visualization. And when we build one of these, we have to consider first how
we're going to lay it out. Do we want to do in a depth first fashion,
as this example is? So we're starting at the root and
then leaves are sort of, sorry. Sub types are lower and lower and lower,
and leaves are staggered at the bottom. So whenever we had a leaf, we draw it. We don't put all the leaves
in the same place. Contrast that to a visualization
that is bottom up for a tree or hierarchical data set. Here, these are both phylogenetic
trees of various types. We've placed the leaves basically on equal
footing on the outside of the circle. Or on the far right of
the visualization on the right. We do this because they are considered
like the equal current state of the world, especially in phylogenetic trees. What those things are representing, those
leaves are animals as they exist today. And further back are animals that may
have existed and died out in the past, that are common ancestors of these things. And so we're putting all the animals that
exist today sort of on equal footing. And reversing back the common ancestors and placing them where it's appropriate
based on when those things were. So there's a temporal element here that
is constraining the way that this is shaped. But the end result is that it is a bottom
up visualization with leaves at the bottom. So the problem then with this kind of
thing, is that while both of these techniques work very well for simple data
structures that are not very complex. Sometimes we will get crazy, hierarchical data sets that look
things, you know, something like this. So now we have this problem of
dealing with lots of branching. So you can see that blob in
the upper right, that's very dark. That's a lot of branches going out. There's also the problem
of single branch depth. And it's hard to see
in this visualization. But sometimes from the root to the most
outer leaf, takes a lot of steps, and so how do we represent that? So this is the constraints
that we have to satisfy, sort of the problems that
we will try to address. With either slightly variants
of encoding techniques or by using more sophisticated algorithms. Usually encoding techniques are
what we need to do or interaction. Okay, so this is an example of
a family tree visualization. The width of that is basically
the branching factor. So how wide it goes at its widest point,
or even within a sub tree? Is there like one sub tree that is really, really wide that might have excessive
branching that we have to deal with. And then the other problem
is the single branch depth. So how deep do we go from
the top down to the lowest leaf? You can see that there's like
one particularly crazy sub tree. That is going to drive
a lot of the visualization. Everything at the top
is kind of compressed. But because we have to fit
the entire tree from top to bottom. We have to lay it out in this way. Emphasizing that single branch,
which may be undesirable. So based on that, we have to pick
maybe alternative techniques to satisfy our need to visualize this data,
but also make it readable. So this is the single branch depth. Okay, the takeaways, we've already covered
a little bit of the hierarchical data structures, their trees and dags,
and no cycles are involved. Common visualization approaches,
just as a reminder. Are these node-link techniques and
space filling, which will see many more
examples of in a minute. But the extremes are what
are going to drive our choices. So thinking about sort of the variation,
the variability of the data. And also when there's a ton of branching
or the branch depth is way too big. That's going to be
the driver of our choices. All right, and with that,
thank you for listening.