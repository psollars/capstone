Hello, in this video we're going to
discuss agglomerative hierarchical clustering, which is another algorithm
that we can use for community detection. The idea of this algorithm is that
unlike the Gervin Neumann algorithm. Which starts with all of
the notes in a single community. And then as we remove edges from
the network using edge betweenness, we end up with all of the notes
in their own community. We're going to do this backwards.
We're going to start with all of the notes in their own community, and then we're gradually going to join
communities to increase modularity. So we'll merge different communities, that give us the largest
increase in modularity. And we'll keep doing this
until we can no longer find, any pair of communities to join,
that would increase our modularity. So the algorithm is the following. We placed each node in
a separate community. Then we'll join two communities, that results in the largest
increase in modularity, if any. And we're going to repeat step two until
joining communities no longer leads to an increase in modularity at
that point we'll stop and whatever current partition we have is
the one that the algorithm outputs. So let's run an example. We'll start with the same network
that we use for the algorithm. And we'll start by placing each
node in a separate community. So we'll start like this. Now we measure the modularity
of this partition. And of course, this partition probably
should give us a pretty low modularity since it's not a very good one. And indeed,
we have a negative modularity score. Then we're going to find
the pair of communities. That gives us the largest increase in
modularity if we joined them together. This does involve checking
all pairs of communities, and seeing what happens to the modularity,
if you try to merge the two of them. So in this case, what we find is that if
we merge L and K into just one community. We'll have the largest increase in our new
modularity score is now a negative 0.045, and we'll keep going and find the pair of communities that give
us the largest increase in modularity. In this case, it's going to be CF. And our new modularity is 0.008. Next IJ. And joined and we're at 0.059. Next we get AB together in a community. And now we're at 0.109. Next we're actually joining all those
four notes into a single community. And we're at 0.176. Next we joined the two. And keep going. So far we've been finding every time
that if we join two communities we get an increase in modularity. So we do not stop yet. And this is where we're at,
are we doing this to keep going and our modularity is now 0.360. We're now getting very close to the point
where we have just the two communities that the Garvin Newman algorithm gave us. And in this case,
this is what we're going to get. We're at the point 0.375 modularity, and
this is when we have two communities. Now in this particular example,
we happen to have two communities. But in other networks, we might find
that we will stop much earlier. If again, we don't find a pair of communities that
would lead to an increase in modularity. So in summary, the agglomerative hierarchical
clustering works in the opposite way. From the Gervin Newman
algorithm we'll start with all of the nodes in
their own community and we'll merge communities that give us
the largest increase in modularity. And whenever we're at a point, when we can
no longer find a pair of communities that would increase the modularity. Then we stop at that point and
that is the partition that we choose.