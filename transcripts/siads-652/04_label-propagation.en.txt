Label propagation will be the last algorithm we look
at for community detection. It works in a similar way as agglomerative
hierarchical clustering, which we looked at last time, and that we start
with every node in their own community and then we'll start merging
the communities. But in this case, we
will not use modularity directly in order to decide
how to merge the communities. Let me tell you how it works. First, we will assign
each node a unique label. This label will tell us which community the
node will belong to. At first, every node belongs
to their own community. Then the labels will propagate throughout
the network in stages. At each stage, nodes will adopt the most popular label
among their neighbors. The node will look
at the edges and look at the label of the nodes
that they're connected to, and then choose the
most popular label among the connections. Oftentimes, there will be ties. A node will look around and there will be a tie for
most popular node, and in that case will
break those randomly. The node will choose one of the most popular
labels at random. The algorithm will stop
when every node has the most popular label
among its neighbors. At that point, the labels will indicate the
partition of the network. One of the problems of
this algorithm is that the outcome depends on exactly
how we do the updating, the ordering of the updating
and how we actually do it. Let me tell you about
possible ways of doing the updating and the pros
and cons of each way. One of the ways is
asynchronous updating. In asynchronous updating, we choose a random
ordering of the nodes, and we update one node at a time. Let's run an example of this. We start out with the network, and now we have labels next to the nodes that indicate
which community there in. Right now, we have a unique
label for each node. Next, we have to choose
a random ordering for the updating, and here I chose
a particular one. Let's see how the updating works. We'll process node A first, since it's the first
node here on the list. A has two connections, B and C, and the labels of B
and C are 4 and 2. So A has to choose
between one of those two, there is a tie for most popular. Let's say that A in this
case chooses label 2. Next, we'll update node J, which is right here. It has two connections and
the labels are 8 and 12, so J will choose
one of those two at random, let's say
it's chooses 12. Next is L, and L has
only one connection. It will definitely adopt
whatever label this node K has. In this case it's eight, so L's new label is eight. Next is K, and K has four
neighbors that have labels, 8, 6, 10, and 12. There is a tie for most popular, we choose one of those at random. In this case, let's
say we choose eight. Next is G, and G has two connections and the
labels are 10 and 12. G will choose one
of those at random, let's say it goes with 10. Next is C, C has five neighbors
and the labels are 2, 4, 5, 6, and 3. They're all unique, so C will choose one of
those at random, let's say it chooses 6. Then B, B has connections
with labels 2, 6, and 10. We'll choose one of
those at random, let's say it goes with six. Next is I, and I has three neighbors and
the labels are 10, 10, and 12, so I will
definitely choose label 10. Next is H, and H has four
neighbors and the labels are 6, 10, 10, and 8, so H will stay with label 10. Next is E, and the
labels are 6, 5, and 8. E will choose one
of those at random, let's say it actually
stays with six. Next is F, and F has
only one neighbor, so it will take whatever label this one has, and that's six. Finally we have D, and D has two neighbors
that have labels 6, both of them, so D
will change to six. The next question
is, are we done? Is it the case that
all of the nodes have whatever label the majority of the neighbors have,
and the answer is no. You can see there are a couple of examples that do not work. For example, A has two neighbors, they both have labels 6 and A currently has label
2, so we're not done. That means we have to choose
another random ordering and do the whole thing again. Let's say we choose this ordering and let's walk through this, maybe we can do it a little bit faster since this
is the second time. First is node B, B
has connections with labels 2, 6, and 10. Ten. Again, it will
choose randomly, let's say, it chooses six. Then A, the labels
are six and six, so it will definitely
update to six. Then I has 3, 10, 10, and 12, so it will stay with 10. K has four neighbors, and the labels are 12, 10 , 6, and 8, so we choose 10 randomly. Then G has two neighbors, they both have labels 10, so it will stay with 10. Then H, which has
four connections, the labels are 6, 10, 10, and 10, so it
will stay with 10. J has two and they
both have label 10, so it will update to 10. L will take whatever
K has, which is 10. Then C will look at labels 6, 6, 6, 6, 6, all sixes, so it
will stay with six. Then E here has
three connections, the labels are 6, 6, and 10, so it will stay with six. Next is D, it has two
connections with labels six, so it stays with six. Finally, we have F here which
will take whatever C has, which is six, it already has six, and it stays with six. Now you can see that actually every node has the label of the majority of the neighbors, so we have finished, and in this case, the two communities that
emerge are these two, and that's the partition,
and we're done. While this looks great, the problem is that, if we run this algorithm again, we can actually get completely
different partitions depending on the ordering
that we happen to use. Because it's random, we can get very different partitions
for the exact same network. Here's some examples of
partitions you can actually get with this algorithm
on this network. You can get a partition
that looks like this, we have three communities, and these are it. It can look like this. So the problem is that this asynchronous updating
tends to be unstable. It outputs different solutions, different partitions, depending on the random
ordering that you choose. That's, of course, a big problem. The other way of updating
is synchronous updating. In this case, each node chooses their label based on
the current labels, and then they all update
at the same time. Since all notes update
at the same time, then the order in
which we determine the new labels doesn't matter. Let's now walk through a synchronous updating version of the label propagation
algorithm for this network. Since the ordering in which we do the updating
doesn't matter, or at least the
ordering in which we determine the new
labels doesn't matter, let's just do it alphabetically. Let's start with A. Again,
A has two connections, two nodes, and the
labels are four and two, and there's a tie, so it will choose one
of those at random. The key difference here
is that we're not going to update the label of A yet. We're just going to write
down next to it what the new label will
be once it updates. But first we will determine the new label for
all of the nodes. B will choose one of the
labels at random, one. C will choose one of
the connections at random, which will be six. One thing to note
here is that I am not looking at the red labels yet. When I look at C
and I look at what the labels of the neighbors are, I'm still looking at
the black labels. A has one, B has four. A will have two but
doesn't have two yet. So that's a key difference here. D will look at two and six, choose one of those at random. E will look at two and five, choose one of those at random. F here will look at C, and C has label two, so it'll adopt that one. G will look at these two, 12 and 10, so it'll pick
one of those at random. H will look at 4, 11, 12, and 8. Right now they're all unique because we have started
with all unique label, so it will choose one
of those at random. I will look at 11, 10, and 9, choose
one of those random. J will look at 12 and
eight, choose one of those. K will look at 7, 6, 10, and 9, choose one of those, and L here will take eight. So now that we have determined the labels of all of the nodes, we'll get rid of the old labels, the new labels will become
the current labels, and then we'll run
the procedure again. Since we're not done yet, it is not the case
that all the nodes have the label of the
majority of the neighbors, we have to keep going. Let's do another
round of updating. Let's start with A. A looks around, the connections
have labels one and six, so it chooses one
of those at random. B has labels 2, 6, and 12, it chooses
one of those. C has labels 2, 1, 6. So we'll choose two, since two shows up twice. D, we'll look at six and five, so I'll pick one of those. Then E we'll look at six and six, so we'll actually pick six. F, we'll look at whatever C has, and that's six, so six. G will look at 12 and 10, so let's say it picks 10. H will look at 1, 10, 10 and 9, so it has to choose
10 since it shows up twice. I will look at 10
and eight and 12, so say it chooses eight. J, we'll look at 10 and 9, so let's say it takes 10. K will look at; 8, 12, 5, and 8, so it has to choose eight. Then L will choose
whatever K has, which is nine right now, so it actually switches to nine. Again, the old labels go away and we do the updating
all at the same time now. Now we have to do it
again because we still have not achieved convergence. Now, let me focus
on nodes H, I, J, and K. Let's ignore the labels of the
others for now, mostly. Let me show you what's
going to happen the next time we try to do this. Right now the labels are 10, 8, 10, and 8. Now if we look at H here, this node has four connections; B, G, I, and K. Now I and
K both have labels eight. The other two connections; G and B have different labels and they will have
different labels for the rest of the procedure because they are in different
parts of the network. You can check that they
have different labels, and that means that H here will actually switch from 10-8
because eight shows up twice. I here has three
connections; G, H, J, and both J and H have label 10, so I will adopt that label 10. J has two connections; I and K, they both have label eight, so definitely choose eight. Then finally, K here
has four connections; H and J, which both of
them have label 10, and then L and E. But again, these two have different labels, so the majority will be 10, and then K will choose 10. What happened is that all of these four nodes flipped
from 8-10 or from 10-8. If we try this again, they will switch back, and if you try it again, then we will switch again and so on. This will indefinitely
oscillate between labels eight and 10 and the algorithm
will never converge. We could keep going and
going and going and we'll never achieve convergence
and it'll never terminate. Of course that's a problem.
Synchronous updating tends not to converge. What is the best solution? We have that asynchronous
updating tends to give us different partitions for different runs over
the algorithms, so it's unstable, and synchronous updating
tends not to convert. Now this may not happen
in all networks, but if the network has
a certain structure, which is not uncommon, it will run into this problem. The solution that we use is a semi-synchronous updating that can achieve both
convergence and stability. I'm not going to go
into the details of how semi-synchronous
updating works in a way that's effective. But the essence of the
approach is the following: the semi-synchronous
approach breaks nodes into partitions without connections
within partitions, so partitions of nodes that are disconnected from each other, and they will apply
asynchronous updating one partition at a time. It has a bunch of other little things that it has to get ripe for it to work. Again, I'm not going to
go into the details, but the idea is to combine these synchronous and
asynchronous approach to achieve both
convergence and stability. If you want to see the
details of these algorithm, this is the paper that you
want to take a look at. But this is the
approach that is used, so when we go through
the tutorial and you see the different functions that are used for a
community detection, and when we get to the
label propagation one, the actual ordering or the approach for updating will be this
semi-synchronous one. As I said, this is
the last algorithm we're going to cover for
community detection, but these are not the only ones. There are many different
other approaches that one can take for
a community detection, and if you're interested
in seeing some of those, you can take a look at Mark
Newman's networks textbook in Chapter 4 and it discusses other approaches
that one can take.