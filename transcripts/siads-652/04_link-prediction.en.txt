In the past few videos, we've been looking at
network generative models that make assumptions
about how networks evolve over time and use those
assumptions to generate synthetic networks that
have properties that match the properties of
real-world networks. Today we're going to be
looking at a related problem about network evolution as well that's going to be
a little bit different. Now, what we're going
to say is we have a fixed network and now we're going to try to make
predictions about what this network is going
to look in the future. In particular, we're
going to make predictions about what edges are going
to arrive to the network. This is the link
prediction problem. This problem has
many applications. For example, imagine that you run an online social network
platform Facebook or Twitter and you're
interested in coming up with recommendations
for your users on who they should follow. Well, one way to approach this problem is to take
the current structure of the network of who follows whom and based on that structure, make predictions
about what edges to arrive to the network
and use those as recommendations
for users to find interesting people that
they might like to follow. The link prediction problem says, given a network like this one, can we predict, which edges are likely to arrive to this network. The way we're going to frame the problem is by saying
given a pair of nodes, how can we assess whether they are likely to
connect or not? The way we're going
to approach this is by coming up with seven
different measures that make different assumptions about
when nodes are likely to connect and they're
each going to give a score to a pair of nodes. In the course, we've
already talked about things that
can give us hints about what measures may
work well for this purpose. For example, we've talked
about triadic closure, which is the tendency
for people who shared connections in a social
network to become connected. So what this measure
tells us is that, maybe we should be looking at the number of common neighbors that the pair of nodes has and that will be
our first measure, the number of common neighbors. Let me define this
measure very precisely, even though it's very simple and this will help me
introduce some notation. We'll say that the number of
common neighbors of nodes X and Y is going to be the size of a particular set
and that set is the intersection between
set N of X and N of Y, where N of X is the set of neighbors of X and N of Y is
the set of neighbors of Y. If we take our two example
and we look at the pair A, C we see that this one has
two common neighbors B, D and so we get a two here. This is a pretty
intuitive measure but of course it has some issues. For example, let's take a
look at two pairs of nodes, the pair AG and the pair H, I. You can easily tell
that they both have just one common neighbor, so E is the common
neighbor of A and G and then G is the common
neighbor of H and I. However, these two
pairs of nodes are very different from each
other in the following way. Both G and A have a
relatively large degree, A has degree 3 and G has degree 4 and relative
to the other nodes, this is pretty high
for this network. In some ways it's not
so surprising that they overlap in at least one neighbor. Whereas, if you look at H and I, both have just one connection and that connection happens
to be G for both of them. It seems having one common
neighbor for H and I is more meaningful than having one
common neighbor for G and A. Well, our next
measure takes care of this issue is the
Jaccard coefficient and it's the number
of common neighbors normalized by the total
number of neighbors. What we do is, we take the fraction
of the number of common neighbors that's in the numerator and
in the denominator, we take the union of N, X and N, Y. When we look at the
pair of nodes A, C, which will be our
running example here, we see that in the
numerator we have 2 because they have two
common neighbors but in the denominator it has four because there are four
nodes that are connected to either A or C. The Jaccard coefficient
for this pair is a half. Let's look at the
two pairs that we were looking at before A, G and H, I. Let's start with A, G, well, A, G has one common neighbor, which is E. This gives us 1 in the numerator and
in the denominator, we have 6 because there are six nodes that are
connected to either A or G. The Jaccard coefficient
for this pair is one-sixth, whereas the Jaccard
coefficient for H, I is 1 because H and I have one common neighbor and there's only one node that is
connected to either H or I, so the Jaccard coefficient
for H, I is much higher. The next measure is the
research allocation index. The intuition behind it is
that it's the fraction of a resource that a
node can send to another node through
their common neighbors. I will tell you a little bit more about this
intuition in a minute. But first, let me
define the measure. The research allocation index
of nodes X and Y is going to be the sum over the
common neighbors of X and Y, and one over the degree of
each of the common neighbors. The degree of u. Now let me tell you more
about the intuition and why this one over the degree
of u makes sense. Imagine that we have
two nodes, X and Y. Imagine that X is trying to send one unit of something to Y. This unit can be a unit of information or a unit
of something else. The way that X is
going to try to send this unit to Y is to send it through the
common neighbors of X and Y since they're
not directly connected. In this case, we have only
one common neighbor, Z. What we assume is that X
sends the full unit to Z. What Z does is it's
going to evenly spread this unit among
all of its neighbors. We're going to assume
that Z has degree n, so there are n neighbors
that are connected to Z. Well, if n is very small, then Y is going to be getting a large fraction of that unit. whereas if n is very large, if Z has lots of neighbors, then Y is going to be getting a very small fraction
of that unit. That's why this research
allocation Index penalizes the common neighbors
for having a high degree. It's better to have common
neighbors that have a low degree than a
high degree if we think of it from the perspective of
this resource allocation of sending a unit of information or something
else through the network. Let's look at our example. What's the resource
allocation of the pair A, C? Well, we have to
go through each of the common neighbors and
look at their degree, so we started with B. B has degree three, so we add one-third. Then D has degree three as well, so we have another one-third
for a total of two-thirds. The research allocation index
for A, C is two-thirds. Our next measure is very similar, is the Adamic-Adar index. What we do is instead
of penalizing the common neighbors
by the full degree, we're going to take
the log of the degree. We're going to take the sum over all of the
neighbors of X and Y, and instead of having
the full degree here, we're going to have one where there is the log of the degree. If we do that is
for example A, C, what we're going to get
is 1 over the log of 3 plus 1 over the log of
3 for a total of 1.82. Our next measure comes from the preferential
attachment model. If you recall, in that model, what do we assumed was that haven't node that
has a very high degree, then that node is going to be likely to get even
more connections. If you have a pair of nodes and they both have
a very high degree, we're going to assume
that they're going to be more likely
to connect to each other than if we have a pair of nodes that have a
very low degree. For this measure is
going to be very simple. We just take the product
of the notes degrees. With preferential
attachment score for nodes, X and Y is going
to be the product of the size of NX
and the size of NY, the product of their degrees. In our example, A, C, they both have degree three. Their preferential attachment
score is going to be nine. The next set of measures
are going to consider the community structure
of the network in order to help with
the link prediction. We're going to be
talking a lot more about community structure
during week four. But for now, we're just simply going to assume
that it represents groups of notes that belong
to the same community, either because they have
lots of connections within the group and few
connections across, or because you have
some other data that tells you what
communities they belong to. For example, maybe the
network comes from an organization and
you are able to tell which nodes come from the
HR department and which notes come from the legal
department, and so on. You hope that this
community information can help you with the
link prediction problem. When we study community
structure in week four, we're actually going
to be deriving the groups of notes of the communities directly
from the network structure. But for the purposes
of this video, we're going to assume that
we're given that data. We'll assume that the nodes in the network belong to
different communities. In this case, let's say that the first community
is the nodes A, B, D, and C, and all of the other nodes
belong to community two. The assumption here
is that pairs of those who belong to the
same community and have many common neighbors in their community are more
likely to form than nodes that say belong to
different communities or that have common neighbors who belong to
different communities. We're going to be
using this information about the community
structure in our prediction. The first measure is
community common neighbors. This one says, ''We take the
number of common neighbors, but we add a bonus if you
have common neighbors that are in the same community as the pair of nodes X and Y''. What we're going to call it is the common neighbors
Soundarajan-Hopcroft score, and that's after the researchers who came up with this idea. That measure for X
and Y is going to be the number of common
neighbors just like before. Then we're going to
add something here. What we're going
to add is going to be the sum over all of the common neighbors of
these function f of u, which is an indicator
function that is one if u belongs to the same
community as x and y and zero otherwise. We get this additional bonus that uses the
community structure. Let's go through some examples. If we take the pair A, C, the score for this one
is going to be two because it has two
common neighbors plus a bonus of two because both of the common neighbors
B and D belong to the same community as A and
C. If we take another pair, say E, I, then the score for this one is going to be one because they have
one common neighbor, and that common
neighbor G belongs to the same community as E and I, and so that adds another
one for the bonus, and that's a total of two. Whereas if we were to take two nodes that are in
different communities, so let's say A and G. They
have one common neighbor, but they get no bonus because there is no way that the
common neighbor can belong to the same community
that they belong to because they themselves belong
to different communities. The total here is one.
We can also apply this to the Resource
Allocation Index. What we'll do is we'll measure the Resource Allocation Index in the same way that we did before, but we'll only consider nodes that are in
the same community. The way we can write this
down is the following: the Resource Allocation
Index Sundararajan-Hopcroft score of X and Y is going to be the sum
over the common neighbors. Now we have this
indicator function, f of u and the numerator, and the degree of u
in the denominator. Whenever you have that X and Y do not belong to
the same community, then this numerator here
is going to be zero or whenever the common
neighbor does not belong to the same
community as X and Y, then again, this indicator
here is going to be zero. We're going to be adding one over the degree of
u only when all X, Y, and u belong to
the same community. If we try this for say, A, C, we get that, in this case, is the same as the regular
Resource Allocation Index because they both belong to the same community and both of the neighbors belong
to the same community, so we still get two thirds. If we try it for the pair E, I, we get that all
three nodes, E, I, and G, common neighbor belong
to the same community, G has degree four, so the score will be one fourth. But if we take two
nodes that are in different communities,
like say, A and G, then is going to be
zero because there's no way that any of
their common neighbors belong to same community as they do because they belong to
different communities. In summary, we looked at the link prediction
problem, which says, ''Given a network, predict which edges are going to
form in the future''. To do that, we looked at five basic measures: they are the Number of
Common Neighbors, the Jaccard Coefficient, the
Resource Allocation Index, the Adamic-Adar Index, and the Preferential
Attachment Score. We'd looked at two
additional measures that actually require
community information. Again, for now, we will assume that this
will be given to us, and once we get to week 4, we can actually derive it ourselves based on the
structure of the network. We'll come back to
this link prediction problem when we look at some of the applications of community detection,
and this will be one. For these two
measures, we looked at the Common Neighbors
Sundararajan-Hopcroft score and the Resource Allocations
Sundararajan-Hopcroft score. Now, one thing I will say is that the network is framed as
a prediction problem, predict which edges will
arrive to the network. However, none of these measures directly make a prediction.
They just give a score. What we can do is we
can use some type of classifier and
some labeled data, and we can use these measures as features that
the classifier can take and make a proper prediction about which just will actually
arrive to the network.