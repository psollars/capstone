Welcome back to a continuation
of our Star Wars API. We have loaded all of our data. We have retrieved it,
we've spidered it, we found the new links and
we've loaded it all and so we're completely full. I can say SELECT COUNT url here. SELECT COUNT url FROM swapi. So we're all good. We
got 207 documents loaded and so let's play, right? So we can look for the url inside the body
tag and convert it, right? So there we got a string. We can ask for the url of body where it contains
director colon George Lucas. So we can have a WHERE clause. It's working now. Now again, there's no indexes
involved in here, right? We don't have an index yet. So if we do an explain, we're going to find
that that just is a sequential scan. SELECT body url
FROM swapi WHERE body contains director
George Lucas, and it's a sequential scan. It's exactly what we'd expect. We haven't put anything yet. So let's go ahead and insert 4000 meaningless rows
of Dodge Neon race car SQL. It doesn't even have a
url field or nothing. So it's just extra crud, 4001, and now we're going
to create our index. We're going to create a
generalized reversed index, swapi_gin on the
body with path_ops. And so json_path_ops gives me the key-value pairs and allows me
to look up by key-value pair. It's kind of a smoother thing. So then we've got to be careful because it might
take a little while. Let's take a look at. Let's do an EXPLAIN SELECT
to see if we can turn this SELECT body url FROM swapi WHERE body
contains George Lucas. Well, it's done already. So I don't have to go
about the thing of like, "hey, let's wait a while." Sometimes it happens fast. Sometimes it doesn't happen fast. But if again, if you do this EXPLAIN SELECT
and it doesn't get you what you
want, wait a bit. Have a cup of coffee
and come back. It shouldn't be too much coffee. Okay. So we got an
index. So there we go. So let's like look at some stuff here. Let's say I want to find the films that aren't
George Lucas. So we can say, what are the films that George Lucas was the director of? Do that. There's four of them.
So let's see if we can figure out how to find the films that George Lucas
is not the director of. So I put a big NOT around this, NOT body contains
George Lucas jsonb. I cast that to JSONB. And oops, we got a
whole bunch of URLs. A lot of URLs, not so good, right? Oh, and there's even blanks. There's even some of those pages
are giving me trouble because I put all that extra
crud in to make it big. But so we can fix that with
a WHERE clause, right? We can ask what are
the things where the body url has got a pattern of https://swapi.co/api/films
followed by something. So we can use a LIKE clause. So we can of course do that, and then we'll find
only the films. So those are the films. There's only six records
that contain films. And if we do an explain, we will be bummed out because we'll see that
it's a sequential scan. Now, one of the
things you probably could do is you could say, "you know what I think
what I'm going to do is put a B-tree index on body url." And that should hit
on prefix queries. We could see. But we can look for the films that aren't
directed by George Lucas, the Star Wars films not directed by George Lucas, by saying, NOT body contains
director George Lucas AND body is like a
film, is a film. So that will do it
and we will find it. But that will be a
sequential scan. So that will show us the films, the three films in the
Star Wars that were not directed by George
Lucas, which is fun. So we can do this LIKE clause. You can see the url,
the people clauses. We can see the people
with a LIKE clause and in a sense you could
think of the prefix of this URL as a type. You can see all the species. Species and their URLs, right? And that would be kind of a
useful thing to do. But it means that everything
is a sequential scan. So what we're going to do is we're going to put
a little effort and we're going to
hack the JSON, Okay? We're going
to hack the JSON. We've done this
before and so we're going to hack the JSON
by a regular expression. And so first I'm going to show
you the regular expression. The regular expression is
https://swapi.co/api/, and then parentheses is the
start of an extraction, bracket a through z is the
letters a through z, plus means one or more, and end the extraction. So if you run this
and all it's going to do is the regular expression
extraction on the url. But you'll see that
it says films. If I make this LIMIT 10, see films, species, whatever. These nulls are
those Neon records that I put in, so don't
worry too much about that. Now, if you recall in
the previous thing, when we're going to mess
with the JSON itself, we have to ultimately use the concatenation operator here. We're going to have to do
the JSON deconcatenation. This is a string concatenation double vertical
bars concatenation. So eventually we've got to
do a JSONB concatenation, which means we're
going to eventually construct a big long string, and then convert it to
JSONB and then merge that into body
just like we did before. So let's start by looking at this string which really is
a string concatenation here. type colon concatenated with the regular expression
that pulls the word, the type, out and then
a double quote. So first we've got to build we've got to build a string that represents the new JSON
that we want to put in. And so this is a string
type colon films, right? That is the new JSON. Now, in order to blend it with existing JSONB, that's
a JSON string, we've got to cast that to JSONB by adding the jsonb
cast on there, right? So we'll cast that to JSONB. So it's going to look roughly the same except that this is JSONB, a type of JSONB, which means
we can blend it together. And so if we now look at this, we're going to select the body, this is going to be gigantic, concatenated, a JSON
concatenation, not a string, of this big
long string converted to JSONB. And so I'll select this
but but it'll be really big. Yeah. So somewhere in here, let's find it, let's find it. Let's find type, type films, right? So we've got the URL but we extracted this little
bit in type films, okay? So we've added a bit to the JSON and we've done
this, well we added one to a count in the previous, in one of the previous examples.
But now we've added something to this JSON, right? So we're going to do
an update, which is again this whole body
concatenated with JSONB. That's the record
we just selected. So we're going to
take and pull out the body for all of the records, add the type variable to it. So this is going to do it
for all the records. So I've updated 4,208 records. And now you can select those records. SELECT swapi body FROM oh, no, sorry. Yeah, wrong wrong wrong. body type comma body url FROM swapi LIMIT 5. What did I get wrong?
What did I get wrong? Oh, I'm getting too many of the blank ones so don't worry too
much about that. Okay, so now I've added that. So now I can use this
in a WHERE clause, right? SELECT body url FROM
swapi WHERE body is type species LIMIT 10. So I'm going to pull out the URL, and then I'm going to use a WHERE
clause which will actually find me some stuff and that's
because these blank ones, it went past the blank
ones and got to some that actually had
type equals species, because these Neon, those are all the Neon ones
that I just did so the dang thing would actually do my explains
the right way. So I now have this new
thing. I can talk to it. My index should understand it. And so I should be able
to explain that, and if all goes well the
new field that I did, should do a bitmap
check swapi_gin. This UPDATE statement here, it updated it and then within like a couple of seconds the
GIN was up to date. And if I had done this update and then like right away
did the EXPLAIN SELECT, the index might not have
been completely updated. So the indexes lag a little bit and
this is where I keep saying that the
insert performance, update performance, versus the query performance. And GIN is. This is a GIN with text_ops, so it's the most
difficult to update. But with only 4,001 records,
it's only a few seconds. And so that shows you how
to like augment it, which is another thing. And so now I can actually say, show me what's going on with George Lucas and let's actually just run that
SELECT statement, SELECT url George Lucas. And I can explain that.
And let me NOT that. Oops, not a note. I sure hope that I'm going to
get my index to work because I worked really
hard to make this work. So we're saying, I got my
NOT parentheses wrong here. I'm coding right in front of you. Hopefully I get it right. This is not as easy as it looks. Let's see if I got it. No. What happened? What just happened? The body doesn't contain
George Lucas type films. Oh, yeah, so this is
not going to work because this is all
the things that don't have the combination
of type films. So let me try to fix this. It's going to take a little work. Let's see if I could make this work. So the first not AND body contains type films. Let's get this one right. So
what I'm going to say is I'm looking for
things that have the body that
contain type films. I'm going to add an extra
parentheses back there. It'd probably be be better
if I flipped this, it would make more sense if
I flipped this to the end. Make more sense to me at least. So if I got my syntax right, I'm interested in URLs that
have a body of type films and do not have the
director of George Lucas. And so I've got to have
my parentheses. Oh, I'm pretty sure that's
going to work, boom. Yes! Now comes the big test.
Get rid of those. Those aren't any fun. Those
don't teach us anything. The always payoff is did I get this in a
way that my indexes work, and I sure hope so. So let's run the explain. Hello, Postgres. Did my indexes work? Yay, my indexes worked. I always feel great when I
don't see sequential scan. I see heap scan. I see that swapi_gin worked. So there you go. You will see this without
the mistake. There we go. type is films and body is not and the director
is not George Lucas. There are three films in the Star Wars set for which George Lucas was
not the director. And that is all I have for you. I hope as always that you found this demonstration
useful. Cheers.