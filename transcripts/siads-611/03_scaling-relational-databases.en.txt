So now I want to answer the question,
why not use ACID for everything? I mean, it's so perfect,
it's so consistent, and it's so amazing as I've told you in so
many previous lectures. Why did we even look at BASE? And the key is that it was
difficult to scale databases. And so there's a couple of different
ways to scale databases and we'll go through them. One is what we call vertical scaling and that's just throwing more
hardware at the problem. More drives, more spinning disks,
more channels, more external ports. If you have one port and 50 disks,
it doesn't do you any good. But if you have 50 ports and 50 disks, things
like RAID arrays, like RAID 0 and RAID 1. The idea was to just find ways to increase
the simultaneous bandwidth that we could get from disk drives. And mostly because what databases
are doing is scanning and discarding data to produce a small
data set to give you back, a small result set to give you
back, more CPUs and more memory. So the more you can keep of
your database in cache and ACID-style databases are great
at using memory very well. So you start with 8 gig,
then 16 gig and 32 gig and 64 gig, and everything's better until
you then hit that new limit. So you're just like that was great and
we're super fast. Oh,wait a sec. It's a year later or six months later
and now you need 128. So you can't just throw more disk drive,
more processors, and more memory. And
especially in 2010, 2011, as we were moving from buying our own
expensive hardware to virtualization, it was really difficult to virtualize
large memory and many processors. And so we tended to virtualize
small boxes. So if you wanted a big box with 8 CPUs and
32 gig of RAM because you needed it, you tended to have to do something like either
buy it and put it somewhere, lease space. Or you had to lease it and you had to
make like a three-year commitment because that was a pretty expensive,
$40,000 piece of hardware. And you needed that hardware
because of your database. Another thing for vertical scaling that
there was a couple of years where how do you do your database tuning? Well, they switched to solid state
disk drives, and like I'm a genius. And the answer is yeah,
that was a genius move for a while. And actually SSDs when they first came out
were great because their random access from place to place is fixed
because they don't have to have rotational delays like disk drives do. But then it got even better because
now if you're reading a bunch of tiny little blocks, you can actually send
a thing to an SSD that says since it's like a scatter gather,
read this, this, this. Here's 32 blocks I want you to read,
read them all, and then just tell me when you got them and then
they just start coming back at you. And vertical scaling has been great. But vertical scaling is never enough, right? We never have enough. And so
we've got to find ways to tune. And so one of the classic ways of
tuning a relational database is to add what are called read-only replicas. And you basically have
some kind of software, maybe even a database itself,
that looks at each of the SQL statements. Some of them are not making any
changes to data and some of them are. So an insert, or an update, or a begin
transaction or something like that. And you look at that you go,
we're going to have one master database. And that's a traditional
vertically scaled database. We make it as fast as we can. And we're going to take transactions
that either are going to require statements that require a transaction or
are going to change the database, and we route that to
the master database server. And then as changes are made,
it spews out a transaction log. Transaction logs are how databases
ensure that changes are made. They write it to the transaction log,
then they write it to the actual database. And if something blows up in
the middle they go back and look the transaction log
and they reapply. That's what transaction logs are for. But you can have a number of other servers
that are watching those transaction logs, and then having a replica of the database
and every time they see a transaction, then they add it to the replica. And so this actually is kind of
BASE-like eventual consistency. Now, these are delayed by maybe a quarter
of a second or even less depending on how awesome they are and how fast the
network is and how fast the servers are. So you could think of this as
adding sort of BASE-like read stuff to an otherwise ACID database. And then you know things like basic counts and
selects and joins and transactions that you know have no chance of modifying the
database, you send those to the replicas. And so you could have as
many replicas as you want. You've got to be careful because at some
point you can't have 1,000 replicas hitting some poor transaction log because
there's still only one transaction log. But the idea of read-only replicas released the need to completely scale
the master database for the reads. And there could be brief moments of
inconsistency. But away you go. And now in a way, we'll see
how this becomes kind of a modern hybrid architecture, because this is
already a blend of ACID and BASE, because these replicas are ever so
slightly potentially inconsistent. Multi-master is another kind of thing
where you have two master databases but because the master database has the
responsibility of sort of putting a block on all transactions on the way
until the transaction in flight really completes, there's a lot of coordination
between the masters. And so people have this, but it's really a compromise because
the need to send every lock and every row and everything that might modify
to all of them to say here comes X. I just got a thing to X and
you've got to stop all Xs so that combination of two master
databases has got to be able to coordinate well enough to make
it from the outside world you can't ever have inconsistency. Now of course you can have
this multi-master and now each master has a transaction
log and they've got to talk to each other's transaction logs and
they got to read replicas. So multi-master is something that people
have used at times, but usually it's not a really good solution because of so
much coordination between the masters. At some point, it's better just to
have a bigger master. The other common thing is
multiple store types. So things like profile pictures in
a blogging system or an uploaded picture. You know, you don't really want to
put that in a database. Databases are fine at storing pictures. They're fine at storing blobs. You can put PDFs or
QuickTime movies in a database, but it turns out that it just
harms database backups. And so you tend to say, you know what? For the blobs, for the large files
that I want to deal with, I'm going to have them on some kind of a
shared file system because that's mostly, that's such a read mostly kind of a thing. And so you just kind of have
a hybrid where you just say, I'm going to have a database table
called the where are the files and then I'm going to have a file
system that has files. And in the example I'm using you're
seeing sort of hashed names. It's common to come up with what's called a single instance data store where
you actually read the entire file and come up with a SHA-1 or some other hash
of the file and use that as the index. And then you can actually have multiple
virtual files in your relational database that point to the same physical file. But then when you're actually
going to serve the physical file, like a QuickTime movie or a PDF or
a JPEG, you just use the standard open. You open it, you read it, and
you send the bytes out to the browser or whatever it is. Now you're deciding how to store all
this stuff inside your application. There's no SQL that kind of figures
this out that, that automatically says it's a big blob so I'm going to
do it completely differently. ACID databases do often
store it differently. The problem is things like
backup can be problematic, and so it's nice to have, with this
kind of a multiple store type it's nice to have an independent backup
between your relational system and your file system just because especially
if you're storing your files based on some kind of a hash. The backup is really beautifully
simple for a file system and the backup is a little harder for
an ACID-style relational database. So multiple store types. There's also what I'll call
a multi-tenant pretend cloud. I'm a cloud vendor, but
I really don't have a cloud application. And so what they have is one
bunch of application code. And then they have little tiny
single-instance relational databases, one for each client. And then they say overall,
we've got like 1,000 clients, but you also have like 1,000 databases. And it's not a bad architecture, actually
it's a beautiful architecture in that it lets you have a single application
for lots of clients. But then the fact that it might
have scaled to 10 million, well, no, it just scaled a bunch of different
80,000, how many hundred thousand, it just there's hundred,
hundred thousand person things and now it's 10 million, but
it's not really 10 million. So I'll call this "pretend cloud". It's not a cloud-scale application. It is just a multi-tenant
application that is conveniently architected to look like
a cloud application. And so if we look at this, and
you look at sort of how applications, let's just imagine email. This is a map of higher
education institutions. And so you could think of email,
relational databases were really good at handling things between 1,000 and
a quarter of a million. And so you could imagine an email system
with all the students and the alumni, quarter of a million,
half a million, maybe. And so you got a good relational database. You'd buy some hardware and
size the hardware for that database. And the database grows slowly because
we're only going to pull in 15,000 new students a year, so life was good, right,
because these are all separate databases. And in that kind of fake cloud where
they're all separate databases, they're all the same. These might all be customers of one
company, one cloud vendor of email, but really there's just one database for
each of these and they've still got a quarter
of a million or less folks. And this is the world in which
ACID-based relational databases evolved, is handling let's just say
a quarter of a million or less. A quarter of a million was a
big instance, right? But if you could handle a quarter of
a million, like Oracle and Postgres and MySQL, then we can use you for
the kind of thing, because we had all these
separate little databases. And so that's the state of
databases in 2002. And up next we're going to talk
about like what disrupted this and that is the first generation
real cloud applications. [MUSIC]