So now we're going to get the payoff. We're going to actually make a natural
language inverted index with Postgres. And it's way simpler than
everything I've done so far. Again, the key is you have to understand
where the ts_vector works and how the ts_query works. But once you understand what
those do, stemming, stop words, etc., it's pretty straightforward. And again, I'm working from
www.pg4e.com/lectures/05-FullText.sql. So I don't know,
I might have to drop this table. We'll drop the index. And then we will recreate them. And did not exist. So we'll create our documents which again,
has just an id and a document text field. And then we're going to create a,
this is the critical one, we're going to create an index named gin1
on the docs table using the gin and the index expression is to_tsvector
quote english quote comma doc. So that says take the document column, run
it through a ts_vector with the English dictionary, and then give me a reverse
index for everything that makes it through. Stop words, lowercase,
and stemming are all done. So if you look at this, the earlier thing
I did that was just strings was actually harder than doing an inverse index. So I'm just going to run it. And I'm going to insert some rows,
insert my three rows in there. And then I'm going to insert some filler
rows to make sure that that Postgres knows we're serious. So I did the generate_series insert
10,001 rows of Neon, and some numbers. And remember, it might take some time. It might take some time
to get things to work, so I can do a SELECT id doc
FROM docs WHERE to_tsquery matches the to_tsvector of english doc. And again, look at the WHERE clause and
the expression that's being indexed is to_tsvector
using English dictionary, the doc. That is exactly the same as what's
inside of the gin expression, right? So we created the index, that expression. So we generally know that the kinds of
things that are going to use the indexes are the ones that end like that. Now you can create more than one index. And you can create more than one
index with more than one expression. You can do a lot of
things with these things. But of course the cost of
the inserts and the queries, how much space the index is taking,
how much cost for each index. And let's go ahead and
see if our index, while I was talking, blah blah blah blah blah. Let's do a query EXPLAIN just
to see if it's made it yet. Yep, all the inserts
in that time frame, it was able to process 10,001
documents and insert them. So let's do something really, I don't
know if it'll be interesting or not. Probably not, so let's just try it,
let's just try it. So we're going off
the script a little bit. So I got this CREATE INDEX gin1. I'm going to DROP INDEX gin1,
so now it's gone. Yeah, DROP INDEX gin1. Index is
just data that the database has, so you can get rid of them. And now I'm going to do my EXPLAIN. Away it goes, okay? So now, I am going to create a GIST
index that does the exact same thing. I'm going to copy this line,
CREATE INDEX gin1 ON docs. And the only change I'm going to do is on
the USING, I'm going to say USING GIST. Now, the thing about
the GIST is that it is. And by the way, all those
rows are still there. We still have 10,004 rows in. So the question is,
how fast can a GIST vector a GIST in an inverted search tree? How fast can Postgres make one of those,
versus how fast it can make GIN? because the main advantage of
GIST is that it's easier and quicker to make and maintain. And it's smaller, but you might have
to retrieve a few more blocks of data. So what I want to do is
create the index and then see sort of how long it takes
before the EXPLAIN starts to work. So the EXPLAIN. The EXPLAIN instantly worked. Do you see that? As fast as I could type it,
the GIST was there. Now let's do it again. DROP INDEX gin1. Get rid of that one. Now it's gone. Now I'm going to make a GIN index and
we will see if we can catch it. Having not yet been indexed. So I just made it a GIN,
the index expression is the same. GIN and GIST both know this
ts_vector like perfectly. So I'm going to create it and then I'm
up then I'm going to do an EXPLAIN SELECT again. Boom, boom, boom, EXPLAIN SELECT. Ah, it was too fast for me, so
I didn't get to show you. It made the GIN really fast as well. But I wish I could have showed you that
the GIST happens faster than the GIN. And you get the same rows back,
because the GIN takes care of all of that. So it's really quite straightforward. The goal is to get to the point where your
EXPLAIN doesn't do a sequential scan. That's all we're trying to do, okay? So I hope you found this useful. Cheers!