So now that we've
talked a bit about JSON and JSON inside Python, we're going to talk a little
bit about how we store structured data inside Postgres. So PostgresSQL support for
JSON has evolved over time. I kind of mentioned, and we'll talk a
little more later, about how it is somewhat a reaction to the emergence of JSON-based NoSQL databases, and everyone seemed to like JSON and liked using
JSON inside databases. And traditional relational
databases and Postgres before 9.4 didn't support that. And so people were like well,
you know, I want to use JSON, so I'm just going to leave Postgres. Now Postgres has a lot to
like and a lot going for it. But the question was, was the market going to all
shift to NoSQL databases or were the relational
databases going to add support for JSON. And so you can see the
support for JSON sort of coming into Postgres sort of
slowly, which I think is an excellent engineering strategy where they would put in things like H-Store and then
the simpler JSON format, and then eventually the JSONB format, which is what we
pretty much use today. So there are three
supported column types, and it looks a little weird to have all three of
these column types. But if you think of it from a historical evolutionary
perspective, it's not really nearly as weird. So the H-Store column is
sort of a precursor to all this, and I think it's a beautiful,
beautiful structure. In a sense, it's like
saying I'm going to put a dictionary in a column, just
a bunch of key-value pairs. And later we'll talk
about the idea of, do you really model
every single thing in your UI in another
column in the database? Or do you sometimes just kind of
throw them together in one column because
you're not querying, etc. And H-Store is an excellent way to take 40 columns and collapse, 40 columns that don't
really need WHERE clauses, but you can actually put
WHERE clauses in H-Stores too. So it's a way to also have
an expandable schema. So you can throw a
new column in there, a new data element in there, without actually alter tabling
and adding a new column. And that's not to say that
everything should use H-Store or that you should
never use H-Store, but there are times when it's
really nice to just have a schema-less little corner
of each of your rows. So H-Store looks
like a dictionary, a maps to 1, b maps to 2, and that's in one column.
It's like of like an array. So Postgres has an array column and it also has a
key-value column. And so that maps very well
to a list, a dictionary, an array, an object, and all this sort of linear and key-value
structures. So H-Store is great. It's kind of a good complement
to arrays. But you can't do nesting
in them, right? So you've got one set of
values and that's it. You could name your keys with XYZ something something, you could
get a naming convention, but you're not
allowed to go deeper. So the first JSON that was in Postgres 9.3 and earlier was really a glorified text field. And here are things you can
do with text fields and I'll show you in some
of the demonstrations. Some of the demonstration
you've already seen, where I'm doing things
like digging into a text field using a regular expression and building an index on that and then using
a WHERE clause with that same regular expression and having it do an awesome lookup. It's amazing, right? And so at some point think of
the JSON as just text, and then you do sort of regular
expression work inside that. And then you build some
functions to make some of that regular expression a little
bit easier, etc., etc., etc. And then you have things like the Generalized Inverted Index, the GIN, and you teach it
a little bit about JSON, these text JSON fields, and
away you go. And that's text. So I could see how
you'd put that in an early version because
you can get that in earlier and quicker. And then the JSONB, which is the
really cool column type, it's not a text field. It parses it, it knows
that it's JSON. It keeps the key-value pairs
very nice and very dense. I can just imagine all the
cool optimizations that it can use storing JSON
when it knows it's JSON. It knows what the rules are, and perhaps it even knows
that there's a lot of similarity between
some of this JSON. So the JSONB in many ways has the advantages of
the indexing and looking up and the dense
storage of the H-Store, as well as the flexibility and the nesting and the coolness in general of JSON when
you want to do the stuff that's sent across
networks in JSON, etc. You can read up on the
Internet whether you should be using H-Store, JSON, or JSONB. But I would just say when in doubt use JSONB because that's where the market is going to expect that Postgres will
have to invest more. And so if you want to use something that you know
is going to be sort of focused on by the performance of JSONB is critical to
the future of Postgres. The performance of
H-Store is not nearly as critical, because with JSONB, Postgres is competing
with things like MongoDB and you see blog posts
like the ones I've got, where people are like I
tried Mongo and I quit, and I went back to
Postgres and that makes the Postgres
people really happy and JSONB is the key thing
that makes that happen. So now that we've talked about the things that are not JSONB and a bit of the history
of JSONB, went too far. Let's actually talk
about the JSONB. I'm not going to talk about
H-Store much more or JSON. And so I will do a nice
walkthrough of this, but basically what we're doing in this one
is I'm going back to my iTunes export. It came out as XML data, I converted it to CSV in an
earlier part of the class, and now I'm going to
convert it to JSON and we're going to
load that all up in a JSON to kind of play with our
first real JSON database. And so we're going to make a
table that just has got a primary key, id primary key,
and a body that's of type JSONB. And we've got a clever
little copy command, that clever little copy
command is reading a file of JSON that every line
is itself a JSON object. We're reading it as
CSV but it's kind of tricky. We're telling it
the quote character is something non-printable and non-existent and the
delimiter character is something non-printable
and non-existent, which means every line
becomes a column, basically. So it doesn't matter because we're inserting
it into body, we're only looking
for one column and so it's reading line,
line, line, line, and becomes row, row, row, row, row with that column,
except that it's JSONB. So that means as this is being parsed and put in and if there was a type, a mistake in the JSON or the
JSON wasn't pretty, this thing would blow
up and say bad JSON. And believe me, I've
done this. As I was making it all work, I blew
it up a couple of times. So the copy command
loads in all that stuff, and then we are going to play
with some of the operators. The coolest operator is
I call it the double arrow. It's dash, greater
than, greater than. What that basically says is when we see SELECT body arrow, arrow, count, and the count
has to be in quotes because the keys in this JSON
are strings, right? The count is a string. So you've got to to look up the
thing inside this JSON body, under the key count. And then this colon, colon int that says convert
it to an integer. And we can do this in a WHERE
clause where the body arrow arrow name is Summer Nights. So that's basically
saying select the count, the number of plays
from jtrack where the name of the track
is Summer Nights. The other thing you can
do in a WHERE clause is use the contains operator, the at sign greater
than operator. This is particular to JSONB. This equal operator for the
body name Summer Nights, that was a string
comparison, actually. Because we retrieved the name and then converted
it to a string. The double arrow converts
it to a string. The single arrow body with one arrow, one greater than, that
would convert it to JSONB, and that would make
that equality not work. But what you have
on both sides of the at sign greater than is in
effect a JSONB document. And so it's really an intersection. It's saying does body intersect with the tiny little JSON fragment
of name Summer Nights. So the key name goes
to Summer Nights. And so it looks through
all the whole JSON and it looks to
see if it overlaps. Is there a mapping,
does it overlap. Where there's an overlap,
that's why it's contains. Does body contain
name Summer Nights? And so that's what the
at sign greater than is. And then the question mark
actually simply says, does this JSONB body
contain a particular key? And you can use these things
in ORDER BY like SELECT body double arrow name AS name FROM jtrack ORDER BY
body double arrow count cast to integer, and then descending. So that's basically the
major fun operators to play with that we have. We will create some indexes. We don't have to
use GIN indexes. You can also just
use B-tree indexes. So in the situation I can say, look, I would like you
to create an index. I want you to look inside the
JSON and I want you to make an index for body
double arrow name. So that's no different
in a way than a column. You could actually
pull that out and make a column called name
and then index on it, or you can just index
right in the SQL. And so I think that's really beautiful. And you don't have to just
have one of those things. And so it means that WHERE clauses,
like this WHERE clause, would be optimized and use the index
to speed themselves up. We can have a GIN, the Generalized Inverted
Index, on the body and that really looks for the key values, and that speeds up things like this question mark operator. And then if we do the more richer
inverted index and we do jsonb_path_ops, that looks at all of the
key-value pairs, and gives you an inverted index
of the key and the value. And that's what speeds
up things like this WHERE body contains
name Summer Nights. And so these indexes, we'll play with those indexes
and create those indexes and then run queries and watch their performance based on
those indexes that we create. And so Postgres really understands the JSONB. It's very efficient. It's very fast. And it's a critical competitive element of Postgres in the
market going forward. [MUSIC]