So now we're going to get
a little more complex. We're going to take advantage of the naturalness of
our natural language. And so let's take a look
at the sample code. Again, this is in https//www.pg4e.com/lectures/05-FullText.sql, and you can download that. And then let's go and
search for stop words. So here we go. So the idea is we're going to move everything to lowercase, and we're going to have a set of stop words that are meaning-free, like and, and for, and whatever. So let me go ahead and drop
docs with the CASCADE option, and then create the docs. The structure is the same. We could probably just
delete the rows from it, but we'll recreate
it just for yucks, and then we're going to
insert some records. Insert the records in, so we got three records inserted, the same ones that we've
been playing with. So this same thing
that we've done here, we can break the
columns into one row per word plus a primary key
with the SELECT DISTINCT, the unnest and string_to_array
of the doc column. But you see that
some of these are uppercase and some of
these are lowercase, and we want to kind of eliminate
the uppercase and lowercase. So what we're going to do is, the only change we're going to make is we're going to take the string_to_array and
we're going to convert the document to lowercase
before we split it. And that's all we've changed, so we're going to
lowercase it all. So we're going to convert the doc column to lowercase
before we split it. And now you see all those
keywords are lowercase. That already is going to make
our lives a lot simpler. Okay? So we're going to create our docs_gin table,
which is the same. It's got a keyword and
it's got a doc_id that's a foreign key
pointing to docs id. And now we're going to create
a table of stop words. So I'm just going to put one
column in the stop_words. It's a column called word, and then I'll insert into stop_words "is,"
"this," and "and." We don't need too many stop
words, but you get the idea. So you can go
Google on stop words, you'll find there
are lots of lists of very extensive
lists of stop words. We're going to keep it real simple because our
text is really simple. So now what we're going
to do is we're going to basically have a WHERE clause. And so you can sort of see
what's happening here is this is the creating
of the inverted index. And so we're going to add a WHERE
clause to this thing we did before where the
keyword is not in, and then a sub-select will
select word from stop_words. So we're going to
split the documents into words, lowercasing them, and then we're going to throw away the words that are
in the stop word list, and then, we're just
going to list them. So selecting DISTINCT
id, s.keyword, and FROM docs with an unnest
and a string_to_array, and WHERE they're NOT
IN the stop_words. So you see that
now that we've put that WHERE clause of
the stop words in, a lot of words went away. Let me see if I can edit it so that I just don't even
have that WHERE clause. So I do the same thing
without the WHERE clause. This was what we did in
the previous example. Previous example, you
see we had 22 rows, and if we do it with
the stop words, we have 18 rows. And so all the rows have
been thrown away, We've also lowercased it, and so that lower is in
there, and away we go. Now, all we're
going to do is take that same SELECT DISTINCT, and we're going to
insert that into our inverted index just
like we did before. So we're going to INSERT
INTO docs_gin and then the SELECT DISTINCT
with the WHERE clause. So we end up with 18
rows in the docs_gin, and so we can do the same
kind of a query. Now, we do have to
convert like lowercase. This query is the same as before. All we did is we didn't put as many things in the
stop_words. Okay? So you can see something like
I can do the same thing we did, where you can do a
multi-word query, but let me go to
this next one with the stop word query where I'm looking for a keyword of and, and now I'm seeing no rows. Because, in a sense, what
we're doing is we're going through the docs_gin, looking up the keyword, and then we're joining into the docs table from the docs_gin. Because the WHERE clause
doesn't find the keyword, because the keyword isn't
even in the docs_gin table, so we never put a stop
word in the docs_gin. We did all the work of stop words as we constructed that table. Okay? So that's stop words. Now, another important aspect of natural language is
what's called stemming. And in stemming, we transform
certain words into their stems. In this particular thing, I'm going to say that teaching
is stemmed down to teach, and teaches is stemmed
down to teach, and teach equals teach. right? So these are all words that
we're going to take that are slightly more complicated
or flowery ways of the same concept. And so teaching and teach
are the same concept, and so we map them
from the words. And we could say instruct
maps to teach, even. So what we're doing
is we're stemming. So I'm going to
insert a two-tuples, right? First, I've got to to
create the stem table with a word and a stem. So the first column
is the original word and the stem is kind of the
reduced version of the word. And the idea is it works if multiple words map
to the same stem. So let's go ahead and make that. So I've got two rows
in my docs_stem table, and so we're going to
do the word extraction, and we're going to move
it into a sub-query. Just to make it a little
clearer what's going on, we've got this SELECT id, keyword FROM sub-query,
SELECT DISTINCT, etc. And so there we go. And what I'm going to do is
I'm going to join that, right? I just wanted to show you that. So we've got this SELECT
DISTINCT id FROM keyword, right? That gives us the IDs
and the keywords. The stop words have
already been taken out, and by taking that as an AS K, what that creates is
something I can join on, and then I can join with what's called a LEFT JOIN onto
the stem table. AS S just gives me a
nice thing to say, I'm interested in the keyword in the gin table matching the word, which is the leftmost column. It's probably just
as easy to show you this because we're going
to get three things. So what's cool about a LEFT JOIN, so I looked up all
of these things, id and keyword are
from the docs_gin, and then you see stem over here. If this was not a LEFT JOIN, it would only show me the
rows where there was a match. So what I did was, I looked up in the stemming table what the stem was for the word teaches, and I looked up in
the stemming table what the stem was for
the word teaching, and they're both teach. But the rest of them are
blank because and, and other, and from, and should,
they didn't have stems. And that's just because I
didn't make stems, but you can see this LEFT
JOIN allows us to do a conditional lookup without
losing all the data. And then what we're going to
do is we're going to is we're going to, in a sense, prefer the
stem over the word. But and, and fun,
and is, and other, and python have no stems, so we're just going
to use those words, okay? So we're going to look
this up if it's there, and if it's there,
we're going to use it. We're going to look teach up. If it's there, we're
going to use it. Okay? So let's take a look
at how we do that. So now instead of just
selecting id, keyword, and stem from the two tables, I'm going to say SELECT
id and then a CASE. CASE WHEN stem IS NOT
NULL, give me stem, ELSE, give me keyword. And AS awesome gives it an alias. And then I'm going to also pull
out the keyword and the stem. The rest of this, LEFT
JOIN and all that, that's from the previous example. So there we go. So awesome is in effect
a derived column from keyword and stem. When stem
is not null, take the stem. So in this line here, where teaching line,
I use the stem. In the line like
stuff right above it, there is no stem,
and so I use stuff. And so this is the way
CASE when stem is not null, then stem, ELSE, keyword. This is sort of if-then-else, but it's a data flow-based
if-then-else. I love this, it's
really a cool way. It's not like if, do
whatever, it's a case. It's like when this happens,
choose this value. When this doesn't happen,
and apply it to every row. Just like most things in SQL, there's an implied loop. Okay? So that's one way of preferring the stem over the keyword. Okay? And there's even a prettier
way to do that and it's using a function
called coalescing. And the idea of coalescing is
that it's a function that takes any number of parameters and it returns the first
non-null parameter. So if I say SELECT COALESCE
NULL, NULL, 'umsi'. Let me just grab them
both and run them both, just to show you how they work. So if you say select NULL, NULL, 'umsi', it
gives you do umsi. If you say SELECT
COALESCE 'umsi', NULL, 'SQL', you get umsi. It returns the first
non-null value and ignores the rest of them.
It'll go through as many null values discarding them as you like and then find
a non-null value. So we can actually express in a bit more elegant way
in this next query, SELECT id, COALESCE
stem and keyword. So what I'm basically saying here is COALESCE stem, keyword, the keyword's always going to be there and stem might be there, but stem might be
null because I did a LEFT JOIN on docs_stem. So if the stem is there,
I'm going to hit stem. If stem is not there,
I'm getting a null because the
LEFT JOIN gives me a null in rows where
there was no match. And so COALESCE just sort of
flattens that down preferring the stem with a
fallback to the keyword. You can almost think of this
as like a get in Python where you have a default
value, but it's not. So this is a very pretty way, this COALESCE is a prettier way of grabbing the index, basically. And so you'll notice
that teach shows up several places and teach was
never in our original thing because we used teaching and teaches and mapped them both to teach, which
is their stem. So the idea now is we can sort of go through and look up
keywords with stems. So now what we're going to
do is we're going to take that SELECT statement and we're going to insert
it into docs_gin. And so we're simply going
to take this stemmed, we're going to make a reverse
index of stemmed words. Not the original
words, stemmed words. Stop words are gone, I
think, in this, yeah. No, stop words are not gone. That's going to insert
just the stemmed words. Now we're going to actually add, probably I should take that out. Really it's most fun if we
do the stop words and the stems. So I'll just delete
from docs_gin and now I'm going down to the
one where I'm doing the stop words and the stems, INSERT INTO docs_gin, SELECT id, COALESCE stem, keyword from
this giant sub-select. And this sub-select has the WHERE s.keyword NOT IN
SELECT word FROM stop_words, sub-select within a sub-select, which that's going to
throw away the stop words, and then we're going to
take that whole thing as K. And then we're going to
LEFT JOIN it into the stem, and then we're going to COALESCE
the stem and the keyword together so that we will end
up inserting stemmed words. So this is stop words and stemmed words all
in one glorious, coalesced, left joined, sub-selected magnificent
awesomeness. So now, if we say SELECT star FROM docs_gin LIMIT 10, we will see stemmed words, we will see stop words handled, and stemmed words. We have docs_gin has our inverted index, which
is a pretty, pretty thing. Now, the key is when we're
building a WHERE clause, if we are looking for a word, we have to also look
for the word or the stem of the word and we have to prefer the
stem of the word. So if we look at
this SELECT COALESCE and then we have two parameters. The first parameter
is a whole sub-select. I might remind you that sub-selects are inefficient but
we're data miners, so we're less concerned about efficiency and
more concerned about awesomeness and really
getting Ninja Warrior good at SQL, which we're doing. So you can see this COALESCE
has two values and one is a lookup to see if there is
a stem for the word SQL, we're mapping it to lowercase, and if we don't find a stem, fall back just to SQL. So we've got the stemming here and the going to lowercase
all happening. And so that particular
one had no stem, so SQL has no stem. But if I do the same
thing with teacher, you see that I get the stem. So COALESCE SELECT stem FROM docs WHERE word to
lower equals teaching, and then fall back to the
lowercase version of teaching, I've been coalesced into teach. So this way I am
using the stem if it's available and using the word if the stem is not available. Now, we don't actually
have to worry about stop words because stop words have already been removed before we created
the inverted index. So it's never going
to find a stop word. Stop words they're as if they never we didn't pull them out of the documents
in the first place. We pulled them out of the documents, but then we didn't put
them in the index. So that's how stop words work, they just block things. And so if we want to do this
stem in some queries, we can just do a
SELECT from the docs, joined through the docs_gin
where the keyword is, and then this COALESCE
statement to do the stem lookup and
prefer of the stem. And so we find three rows
that match the And if we do the other one
with a SELECT DISTINCT id, doc where the keyword
is the coalescing of the stem for teaching
or teaching itself, in this case, the
stem is going to work and we're going to find the ones that
match the teaching stem. But the original documents
have the word teaching in them and teaches, and so that way, we looked for teaching
but we also found teaches, and that's
because we stemmed them down to the same word
in our index and then we reconstituted it all because we're looking at
the original documents, not the post-stem documents, okay? The technical term for
converting stems, search terms to their stems,
is called conflation. I've always wanted to
use that in a sentence. So I hope this has been helpful
to you in understanding how stemming and stop words work when building natural
language inverse indexes.