Hello and welcome to our lecture
on database architectures. So if you have taken any
classes from me, you've seen this slide whenever I
talk about relational databases, whether it's MySQL or SQLite or
even Postgres in an earlier class. Every time I give this slide, there's this little part inside of
me that like sort of breaks my heart because I'm trying in the beginning to
give you a set of rules that are simple and easy to understand, and database
normalization is a very hard concept. And so I'm oversimplifying here. This this notion of don't
replicate data is most of the time. And the reason I just in the beginning say
it's all the time is because most people when they first start out
don't need to know that you you can replicate data if you feel
like it. Because it's not true. You don't replicate data
if you feel like it. But sometimes you are forced by
the size of your application and the scale of your application
to do the replication. And so it's usually true and
I'll honestly say 95 out of 100 times that people say "You know, I'm just
going to replicate data," they're doing it for the wrong reason,
and that's because they're being lazy and they're not really trying and they don't
want to understand data normalization. So don't replicate data until you fully
understand database normalization. So a lot of this evolving database
architecture is captured in this sort of NoSQL movement. You know, is SQL the
right answer or is there something else? Is there something that is better than
SQL that's going to be super cool and whatever. And there is so much in technology,
this sort of wheel of what's new. Some people like say it's this tech
circle where you just rediscover something they did 15 years ago. And so NoSQL in a way is kind of like
just storing stuff on disk rather than in a database. Which of course, is also
on disk, but storing stuff in files. And honestly, in 1996 we wrote a lot of
web applications that did nothing but store everything in files and then we
realized they didn't scale for things like transactions and money. And so you just couldn't do it in files
because you're rewriting the whole file too often and then you
start writing indexing. And then you need transactions. So this NoSQL, in a sense, was a movement
that kind of came in 2010, 2013. It says like SQL is bad,
it's too constricting. Look at this cool thing I found. And the answer is no, we all
found that 20 years ago. And then we decided it
wasn't such a bad idea. So this is really not the right
question is whether or not SQL is a good idea or not,
because SQL is just like a shape. It's a syntax that we use to
communicate. A better question, almost, is whether or not it's relational.
Is this a set of rows and columns? And again relational, to remember, is at
the connection between a row and a column. That's the relationship.
Not just rows and columns. That's a spreadsheet is rows and
columns. Is it that, or are there a set of documents with
key-value pairs in those documents? And that is the non-relational way of
thinking about it, that they're not really columns. They're sort of one blob of
text. Inside that blob of text, there's a whole bunch of key-value pairs. And these days this isn't even a good
sort of way to split the market. Really the way to split the market I think in a healthy way is
to use the term ACID or BASE. This is the best question to ask and it is a question that is more about the
underlying truth of how databases work and less about the syntax of it or the storage
tricks that happen to be used by it. And so this is a nice true
technical difference between some of the old traditional
databases like Postgres and the new databases like Mongo or Cassandra. And so let's look at the ACID and
the BASE acronyms. They're both a little bit contrived,
although the ACID is much older. The BASE is sort of like a more
recently convenient thing. So ACID stands for Atomicity,
Consistency, Isolation, and Durability. It can really be summed up with
these databases go to great extents to ensure that if there is some
value at a row-column thing that has a 42, and if everyone is
simultaneously looking at that, it says 42 no matter who's looking at it.
And that's over time. And if it changes, then all of
the viewers of that information, so it's simultaneous writers and
simultaneous readers. If everyone is trying to write at it and
everyone is trying to read at it at a given moment in time, maybe
a millisecond later it's different. But at a given moment time, everyone
is seeing the same thing, and that's the consistency. When you make a change,
it's isolated from the other changes. One writer might set it to 2 and one
moment later set it to 4. That's okay, as long as it was 2 and
then it was 4, not like 2, 4, 2 for a little while again,
4 a little while, etc. And that's the isolation that
everything you do happens, and then when it's done, it's done and
it doesn't seem to move backwards in time. Durability just means that it stays there. So BASE, which is the more contrived, it's really eventual consistency
is the operative concept here. BASE means like it's pretty much there. You know, it's not as picky as
the ACID and state is soft. I don't know. But eventual consistency
means that if there is a value somewhere in this blob of stuff of X
in it and somebody sets it to 1 and everyone looks at it and it's a 1 and then somebody sets it to 2, for a
while, depending on who's looking at it, it might either be a 1 or a 2, but
then eventually it's a 2, okay? So if you wait long enough
this system will sort of percolate the change from the 1
to the 2 through everywhere and all of the readers will eventually see
the 2. It's not that it's not consistent, it's that eventually it's consistent. It's not guaranteed to be consistent. And so you might be a reader and
you might say what is it? It's a 1, what is it? It's a 2. And then you might even
ask again, what is it, and get a 1. But eventually, after
like five minutes, it's a 2, okay? So that's the basic idea. And so here is a diagram of this
where we have one writer that this X has a value 42 inside of the
black box that is a database. By the way, even though some of you
may be colorblind, this is in red and blue
for ACID and BASE, but the color doesn't really mean
anything, it's just kind of cute. So we've got a value inside of the system
of X which has a value, of course, of 42, and then here comes a dog, hi dog. Are you just listening and hearing me give
lectures and so you decide to come in? Okay, you can lay down there for a while. Sorry, that was my dog. Hey Shelby, how are you doing? I have to put a picture in
of you, how cute you are. So I start giving a lecture and
the dog decides to come in. And so here we go, we've got one writer
that's going to set it to 10 and one's going to set it
to 20 simultaneously, meaning they're just
racing towards this data. And you've got a set of readers that
are asking what is the current value of X? And they're seeing 42 at this point. The writers have not done anything. And so what happens at some point
is the database decides, probably by arrival or anything. It doesn't matter, because these two
things don't know what time it is. But at some point it picks something
and it says okay, this transaction is going to happen. And
while it's making those changes, and to the extent where it has
to inform all the readers, it says I'm blocking the X equals 10 for as
long as it's going to take until everyone who reads it's going to see a 20, meaning
that you're watching it and it's 10, 10, I mean 42, 42, 42, 20 and
it stays 20, 20, 20, 20, 20. It doesn't go 42, 20, 42, 20. It's consistent. When it changes
to 20, it changes to 20 and doesn't bounce back and forth. And then once that is finished, it's not like we're prohibiting
it from ever being changed again. We just then let that one through
and then the readers whatever it has to do so that everyone
sees it 20, 20, 20, 20, 10, 10, 10, 10 10, not 20, 10, 20, 10. Okay, so you get it? So that's ACID, and it's all about
sort of like setting this barrier and stopping transactions from coming
in once a transaction is made it into kind of the inner
circle of this thing and putting up this little wall that
stops things from coming in. The key to BASE, or eventual consistency
systems, is they are much more scalable because they spread the data
out using many copies, right? They are replicated and
this is the old don't replicate, the whole idea of don't replicate is so
that that ACID can work, right? So if you have one number, it's really
one place in the database and it's not 42 places. But if you have multiple servers, you could have a thousand different
servers and have a thousand copies of X. And then your readers can like just
like read willy-nilly, right? Your readers can read willy-nilly. So the thing we've introduced here in this
BASE style is we have kind of a timestamp. And so we have many copies of X. We have three copies of X of
a value 42 at time 0, right? Now the key thing here is this is
eventually consistent. X has been 42 for a long time and all the copies of X are 42
and all the copies of X are 42 at time 0. So no matter how many readers
you have, you say what's X? They're all going to see 42, okay? They're all going to see 42. The incoming integers are racing. There's multiple writers that are going
to try to set X to 10 and set X to 20. Now the key is that in
a BASE-style database, any of these systems can be the one that
receives the request to change X to 10. And so it changes its copy of X to 10.
But it also has to mark the time that it happened because you're going to see
because we got racing happening, right? So we set X to 10 and we know that X
in this middle system is 10 at time 1. And so if you're asking now, what is X? Well, depending on which of those three
systems you see you might see 42 or you might see 10 or you might see 42. And if you ask again,
if you keep asking and we've sort of stopped this in time,
you might see oh, it's 42. Oh, let us ask again, it's 10. Oh, no, it's not. I ask again, it's 42. So this is the inconsistent moment where
depending on the reader, the same reader. Now, if it's kind of cached and sticky and
all that you might see it not change. But the point is you technically could
see in the outside world of watching, X is either 42 or 10. And the 42 ones don't know that
they're invalid at this point. Now, they're like if there was
a cache there'd be invalidation, we can't afford that kind of
coordination at this point. We can't get them all simultaneously
to change because there's 10,000 of them, right? They're all over the Internet and
there's 10,000 of them. We'll get there. So at this point X is
an inconsistent state. Different viewers will see
different values of X. One viewer can see X flipping back and
forth between two values. And then the next thing that happens is
actually before anything else happens, X equals 20 finds its way to another server. And it's not going to that same server
because there's 10,000 of them. And so the second server, the third server at the bottom now
has X with a value of 20 at time 2. Now, we're done here. And so the problem is is that if you're
a viewer you might see 42 or 10 or 20. And a single viewer might see it sort
of flipping between 10, 20, and 42. You're just like what is it? It's 42, it's 10, it's 20, it's 42, it's
10, it's 20, it can go back and forth. Because again the routing of the read
request might go to any of these three while it's in this inconsistent state. We've paused it and it's in
an inconsistent state and away we go. But we've got to fix it because we do
have to have eventual consistency. So more time passes and the
middle server says, you know what? I'm going to start telling everybody about
my great news that I have a new value for X at time 1, and it sends it
to the bottom server. And it's like sorry, Mr. Middle Server,
we have a time 2 value, so you're no good. So we'll just throw away
your requested update. It's like, oh, okay. And at this point again, we have three
possible values of X at any given moment. And then the middle server decides to talk
to the server which had a 42 at time 0 and it's like yeah, 10 at time 1 is
way better than 42. So it's getting less inconsistent in that you can only see the value
at this moment of 10 and 20. And of course, you can guess what's
going to happen is that the bottom one wakes up and decides time to forward
all my data to all my 10,000 closest friends connected on the Internet. So it goes to the first
one, which has got 10 at 1. It's like well, 20 at 2 is better
because it's later. And that one updates it. And we
still are inconsistent. And now we communicate between the third
server and the second server in all of the data and this happens
10,000 times or whatever. And so this is eventually consistent. Now, for now from time going forward
no matter how many times you ask and no matter how many servers you end up
touching in the asking, X is now 20 and it's going to stay 20. And so the question really is how
long did it take while the value of X was inconsistent? And so you can kind of say, really?
Is that the big deal if it's going to take a half a second or
five seconds or ten seconds? Do we really care? And what if your data is so widely
spread that it's not just an X. It's like a 100,000 Xs and
everyone is looking at different ones. So eventual consistency
is not entirely all bad. It is bad if it's a bank, right? Because eventually something
bad is going to happen, right? So it is bad for a bank. So database software basically works
hard to meet sort of its semantic rules. So you have this Atomic, right? Which in a moment in time
it's always consistent. Things like Oracle,
Postgres, MySQL, SQLite or SQLServer all kind of
classic ACID-based. And then the eventual consistency
are things like Mongo, Casandra, and Google's BigTable and
many others, right? And so basically this is the compromise.
And the idea is that you can scale these BASE systems far higher,
especially within read mostly. And literally almost all
database work is read mostly, although we'll talk a bit about sort of
writes as much if not more as than reads. Sometimes those databases
are a little bit different. And so it seems like it's
a pretty small compromise, but when you're dealing with like membership
in classes and grades and money and stuff like that it actually is a big deal. And it turns out you spend way too much
time in the application recovering from possible errors that are actually
rare in BASE-style systems, but you've still got to go like hmm, I just
created a new account at csev@umich.edu. Okay, hang on, let's wait a second. And this
is actually kind of cool like in account creation when you say I'd
like to make a new account, what's the first thing they do? They send you an email to
verify your account. So your account actually
is not even made yet and what happens is think about what happens
is if you asked to make an account in one browser with this one email address, then
make the account in another browser and email address, and then you get
these emails and you click. So that's the kind of thing to
think about about consistency. Now, most systems when they do new
accounts will have a little relational database just for new account creation, even if they are fully NoSQL/BASE,
that kind of a system. So there are some compromises. One of the primary cool features
of ACID-style databases is SERIAL INTEGER keys,
but you don't do that. In BASE style you actually generate
what's called a Global Unique Identifier that's a combination of
random numbers and the current time that are carefully
constructed to be global. And then that becomes kind of your
primary key. They're longer, but they're not terrible. Like in Postgres, there's
a pretty efficient storage for GUIDs. Transactions ensure that on
an ACID-based database that you're not getting stale data. And you just have to have retry loops
in your application in case there might be stale data and deal with the fact that you've got two
new account requests from the same person because they talked to different
servers when they started. UNIQUE constraints are difficult. Again,
in an ACID database, you could say insert csev on conflict, do nothing, or on conflict,
ignore, on conflict, update. So that's when UNIQUE Constraints are
triggering. In BASE you got none, because you just don't know. You're talking to one
of 10,000 servers and there's no way for them to contact all of the other ones. You have to insert it and then find a way
to recover when you turned out to have inserted the same record.
There's no uniqueness. And one of the things we do when we're
dealing with ACID databases is we build beautiful queries.
We join a bunch of things, we sort of give this beautiful query. we hand tune it, we optimize it, we
get the index just right and then we get a little tiny bit of data back
and it's exactly the data that we want. You tend to sort of like say,
you know what? I got 10,000 servers, let's just hit
them all and see what happens and then throw away the stuff we don't want. And we'll see sort of applications
that use this type of BASE eventual consistency system with a bunch of
retrieve and throw away methodology. So the next thing I want to talk about
is the difficulty of scaling relational databases and why it is that we
turned to something else as we tried to scale relational databases
probably starting 20 years ago. [MUSIC]