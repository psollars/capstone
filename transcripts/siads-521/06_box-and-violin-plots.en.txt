Today we'll be talking
about how to build violin plots in Python
using Matplotlib. Violin plots are used to visualize the
distribution of the data, and it's probability density. As such, they're
really similar or a combination of density
plots and box plots, which we covered in
our earlier session. Let's take a look at an example. First, let's import pandas as pd, numpy as np, scipy stats, and we'll import
matplotlib as mpl. So let's generate some data
from different distributions. Let's do one normal
distribution with a mean of zero and a
standard deviation of one. So we'll do Dist1 equals
np random.normal, and we'll do that
at a size of 5,000. Let's also do a
Pareto distribution. So np random, and then
we'll call eight, five and again it's size 5,000. For the third one, we'll concatenate two
normal distributions. So we'll do comp1 as a
normal distribution, and comp2 as a normal
distribution and then put those
together and Dist3. Finally, let's put all of those three distributions
and merge them together. So let's take a look at a basic boxplot of these
data using matplotlib, mlt.boxplot to visualize
some of the statistics. So we'll do a boxplot of the distributions
we just created. Since this output is a lot, we can just comment that
out with a semicolon, so that way we only get the plot. Here we can see that we get these nice little plots
that have a lot going on. The boxplot itself shows the
interquartile range plus, or minus 25 percent around the mean of
your values itself. The edges here show the
75th, 25th percentile. Finally, each of
these little dots here show the outliers
in our data set. So you can see that with
a simple plot above, we can automatically
visualize that these two distributions
have very similar means, at least the first two
have very similar means, but different standard deviation, and different
interquartile range. The third variable has
a very different mean and different
interquartile range. We can also add labels here, to see if the descriptive one, two, three are enough, so we can add those
and say one, two, three using plt box, again plotting it and
just adding the labels. argument. Matplotlib
automatically scale this for you, but you can change
the width to make it smaller or larger if you like. So for instance, if we add in the widths argument
and we point to 0.7, then we can see that the
boxplots become wider. You can choose to
pass as a tuple. So depending on what you want
to highlight in your data, you can have one thin data, and one wide, and one very wide. So for instance, if we did
this at 0.03, 0.5, 0.8, we can see that the width of the third variable is much
wider than the others. Well, variable one
is extremely thin, and probably not useful
for visualization. But it's nice to know that we can alter these figures accordingly. Finally, you can customize the appearance of your outliers using the flyerprops
equals feature. Let's make them say green
and diamond shaped. So we'll do green diamond equals the dict markerfacecolor
g for green, and the marker d for
diamond, and plot it again. However, there's some
important information about the distribution that the boxplot isn't really revealing to us. We can visualize the data
using a basic Violin plot, using matplotlib, plt.violinplot. So let's just do this, with plt.violinplot, and we'll
put in our distributions. Wow, we can immediately see that Variable 1 follows a
normal distribution ish, Variable 2 is a
Pareto Distribution and is incredibly unequal. This is often used
in economics to show the unequal distribution of wealth that we see
in the real world. Variable 3 is a bimodal
distribution which you probably already realize when we generated the data by concatenating
two normal distributions. However, when it comes to
dealing with real data, we don't always walk into the data exploration process knowing that the distribution of the data we're already
dealing with which is a main reason we do these
exploratory analyses. So what is being
done here is called a Kernel density estimation, that actually shows each of these distributions as well
as the range of values. This is a really great
way of conveying differences in distributions that you see in multiple data sets. Matplotlib, Violin plots you use the Kernel density
estimation to compute the empirical distribution
of the sample. You can also add some
extra annotations, like showmeans and medians. So if we set showmeans to true, and that adds an extra line
representing the mean. We can also set
showmedians to True, and that will add another line indicating the
middle of the data. So let's try this out. So plt.violinplot
distributions showmeans is True, showsmedian is True. We can see in the plot below that the mean
and median are the same for each of the
Gaussian distributions and the bimodal distribution. But for the skewed
Pareto distribution, they're off a bit. However, having all the
lines to same color makes it a bit difficult
to tell the difference. Now if you want to actually customize the appearance
of a Violin plot, we have to do something a bit different than what
we've done before. Let's make a return value
for the Violin plot. So it's an object that
we can take a look at. So we'll call This violinplt and then we'll plot that
the same way we did before. Now if I print out the violinplt
object, what do I get? You can see that we
get a dictionary which has some keys
among other things. This prints out a lot of stuff. So let's just pull
out the keys for now. These keys are the bodies. C means, cmaxes etc. Each of these corresponds to a different
component in the plot. For instance, the
bodies is a list of objects and the
distributions themselves, and cmeans, and cmaxes,
cbars, cmedians, and cmeans are all of the
elements that are here. So now let's try and change the color of the mean
so that we can see the differences in
mean and median lines in our Violin plot. So if we do violinplt
cmeans here, we can then do set color, and make them say yellow, and there you go. We can easily see
the differences in the statistics now in our figure. We can also change the
bodies themselves. But if we try to do this in a similar fashion,
we get an error. That's because the bodies, unlike the other elements, are actually a list object. So I have to go and access each individually by indexing it. So we'll do violin bodies 1, we'll select the first
one and make that red. Then let's select the
second distribution and we'll make that green, and go ahead and leave the
third one the same color, blue, that it already was. If we wanted to change the line colors for each
of the means or median, we would have to do
something different. An unfortunate part of
Violin plots is that it requires slightly
different syntax for each of these components. So we instead would want to pass this a list or a tuple
for each line like so. So we'll do violinplt
cmedians, set color, and then for each of
our distributions, we'll set the color to r, r, red, and green. So if you pass a single color, it would just give that
color to each of the items. But if you pass it a list, you can see these individualize the colors for each
of the distributions. So Violin plots are a really informative way
to explore your data. As we've seen, they can
have an added value over boxplots when we
are interested in knowing more about our
data distributions.