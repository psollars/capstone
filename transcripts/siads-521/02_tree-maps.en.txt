This lecture is going
to be a bit different because we're going
to explore a kind of visual which Matplotlib
doesn't have built-in support for
called the Treemap. A Treemap is a data
visualization technique that shows hierarchical
data is a set of nested rectangles
varying and colors and sizes depending on
some given data value. So you can see the
relationship between two items in a hierarchies
through the rectangles, but you can also see the
relationship between values of various components
through coloration, texturing, or the like. Now, if you Google
Python and Treemap, you'll see lots of
different articles showing you how to build a
Treemap in Python. They're all wrong as
far as I can tell. Most of these examples
are little more than square pie charts which show one or more relationships
through coloration. Nonetheless, I think it's useful to see both what Treemaps can be, and what we have in Python at
our disposal to work with, and maybe you or someone else will see this
video and take up the banner of actually
implementing a Treemap in Python. So let's start with the original
image of a Treemap from Ben Shneiderman's 1991
technical report, where he shared
the original idea. So in the top figure, we can see that the
tree data structure he was working with is here. There's four main nodes each containing several leaf nodes. Leaf nodes in this
case are all numbered. The figure below, Figure
2 shows the whole tree. Each of the leaf nodes is
contiguously connected. For instance, the nodes 6, 8, and 11 appear at
the top together, and represent one square
from the tree diagram. Nodes 5 and 40 are similarly
next to one another. Then together these
nodes are next to the ones labeled 6, 8, and 11. So the structure of the
tree is represented both explicitly for the leaf nodes and implicitly for
the non-leaf nodes. Now Ben and his team as well
as other researchers around the world continue to iterate
on the design of Treemaps. Here's another example of a
Treemap from the early 2000s. So this is where things get
a little more interesting. What's particularly
important is that now an arbitrary level of nesting is being shown for the
hierarchical data. We see that now binding
activity, for instance, contains both protein binding
activity and nucleotide binding activity and that
this latter category includes several kinds of
nucleotide binding activities. Further, this was built into an application which didn't
just show the visualizations, but allowed for
filtering of data and exploration of other details
of the tree data structure. At the same time, I think
this image also starts to highlight the problems
that Treemaps surface. It's actually really hard to navigate through deep structure, and when there are many
different nodes in the tree, it's difficult to visualize them all and keep the hierarchy clear. For each level in the hierarchy, some form of border
is needed to denote the contains relationship
between nodes, which are realized
as rectangles here. This is even more difficult if the nodes are actually
supposed to be labeled too, resulting in clutter
when trying to scale. So let's see what we can actually do with Treemaps in Python. There's a library called Squareify which helps
a bit and perhaps not surprisingly this
library actually emulates a pyplot
scripting interface, and all of the objects
that it creates are actually just Matplotlib objects. Things like axes,
figures, and patches. Actually, if you want to create your own visualization method
and share it with others, this is a great way to do it, since the underlying objects are actually all managed for you. I've linked here to the
Squareify source code because I think it's actually
pretty simple and readable, and demonstrates how you could
build a library on top of Matplotlib that interacts cleanly with the Jupiter
Notebooks, and who knows, maybe one of you will
decide to improve the Python InfoViz
Ecosystem by forking Squareify and adding to
it hierarchical features. So let's bring in
our regular imports, we'll bring in Pandas, PyPlot, and we'll bring in
Matplotlib at the top level 2. Let's bring in this
Squareify library 2. So we'll import Squareify. Let's take a look at the
Squareify plot functions. We'll just do squareify.plot
with a question mark. So we see that Squareify takes in a list of numeric values, which are the squares
we want to create. In addition, there's a bunch of other parameters we
can pass in including an axes object to plot to a specific axis or
colors and labels. Let's just start with
a trivial example. So let's plot some powers of two. So I'm going to call squareify.plot
and I'm going to pass it a list: 2, 4, 8, 16. Now, the colors here
automatically picked for us, and frankly they're gross, but we can add colors
as well if we want to, and we can set up some labels. So let's take a look at
this in quick round too. So we'll do a squareify.plot, 2, 4, 8, 16 and let's create some labels 2, 4, 8,
and 16 written out, and then we'll set some colors, red, green, blue, and yellow. Well, I didn't really
fix the garish colors, but at least I made
them predictable. We can see that in
Python with Squareify, we really only have a couple of dimensions of data to show, the size and area of
the squares and the color which might represent
some value of interests, and unfortunately,
that's about as far as we can go with
Treemaps and Python, at least as far as I know. Actually, this really annoyed me while writing up this lecture, seeing page after page
of Google search results suggesting that these rectangular pie charts are Treemaps, but there's no hierarchy. So I sat back and
decided instead of waiting for the world to
solve my problem for me, I was going to take a shot at it. So I'm going to share that
journey with you, so let's go. First, let's bring in NumPy and random. We're
going to need them. So we'll bring in random
as a library and NumPy. Now let's hack some
demo data together. For instance, let's say we
had an arbitrary number of directories on file system, so I'll make a dictionary
here directories, and we'll put four directories
in it, videos, images, documents, and
notebooks, and each of these are dictionaries
themselves. For each of these directories, we're going to add a
few files in them, and those files are some size. So for each key in
the directories, I'm going to insert a new file. So that file I'm just
going to give it a name, so like file i, and that'll be just somewhere
between just a few files, somewhere between two and 10, and I use dictionary
comprehension to do that. I'm also going to set a size
of the file here as well. So the value of the file, the key is going to
be the file name, but the value is
actually going to be some size in megabytes, or kilobytes, or gigabytes,
or something like that. Okay. So now we want to measure
how big each folder is. We've got four folders and
they've each got a bunch of different files in them with a bunch of different sizes. So I'm going to create
some new dictionary, pardon me, called
directory sizes, and I'm going to iterate through, and I'm just going to sum
all of the values in there, so that now we have a list
of all of our directories, and how big they are. That is these number of files, or the size of the
piles they contain. All right. So now I'm going to generate a bunch of colors for each of the files and this should be similar
with the directory. So I'm going to bring
in something called colorsys and I'm going to create a new dictionary
called directory_colors. Now, I'm going to
write a function here and actually I'm going to copy it gratuitously
from Stack Overflow. So Sverre Rabbelier has this great discussion
about how to take hue saturation color spaces and how to turn it
into RGB color spaces. So what we've actually
written here, or frankly, that I've
mostly copied from him, is a function called
get_colors and you pass it in, the number of colors
you're interested in, let's say I'm looking
for five colors and you pass it in a seed hue. Basically something like blues or greens or something like that. Through this color
space manipulation it's going to return to you five tuples of RGB values. Now, this isn't
really important for our discussion of Tree
Maps except that there's usually a relationship within a given directory in this
case and different level. So what we're going to do is
we're going to have all of the squares that deal with
one directory, one color. So we'll have a bunch
of blue squares, maybe that's files or videos and we'll have a
bunch of yellow squares, maybe that's documents
or something like that. So now we're going to
iterate over all of the directories and we're going to generate
those colors for them. You see here that I've passed in the hue value as random.random. So we actually might
have a couple of the directories both be blue
or something like that. There's actually a lot of flexibility in this color space, so it should be quite visible. Okay. So now we have
our directories listed in the directories dictionary
with their child files. We now have our
top-level information in the directory sizes group and directory colors
dictionaries. Now, my strategy here is to generate a new axis object for each directory and scale the size of the axis object
to the size of the directory. So we can do this in Matplotlib using the GridSpec functionality. This essentially allows us more finely grained control
over our figures subplots, changing the relative
size of each axis. In this case we're going to
change sizes of the axes in width based on the size of
the files in the directory. So I wanted to be
able to show you the GridSpec layout and this seems like a great
place to do it. So from matplotlib.gridspec
we'll bring in GridSpec and we're going
to create a new figure. We're going to set
constrained_layout true. We don't want our axes being automatically resized
by the figure. I've decided to make the
figure a little bit bigger. So now we're going
to call GridSpec. The key with GridSpec
is we give it a range essentially of things
that we're interested in. So how many grid entries
are we interested in? It's going to return to us
a list of axes objects. We're also passing in the figure, so it associates those axes
objects with the figure. Then this is important,
the width ratios. Now, there's a couple
of different ways we can deal with the grid. But the one I'm showing you here is essentially we're going to take the directory and it's size and use that as a ratio. So maybe one directory
is 420 and the other one's 73 and the other one's two. So then automatically
GridSpec will resize the axes object based on the
figure layout information. We don't have to do
anything special there. Now we do have control
if we wanted to. So gs when it returns is actually an array or a list
of axes objects. So the way I've set this up, there's actually a
significant limitations. I've decided that I'm
only going to have this one row and that each of the axes will be lined up and chopped up based on
its size in that row. This really doesn't scale well, it creates what we might call a strip plot which
reads as left to right. But I think it's sufficient
to show the demo, and I would love to see people take
this and push it further. Okay. Now, I want
to create a list of the axis objects each
associated with one directory. So I'll create this
directory axes and then we're going to iterate through all of the directories. So I'll add this to the list, the results of add_subplot
calling it on our GridSpec and that'll help Matplotlib create the axes and associate
it with the figure. So when I call fig.add_subplot
and I pass in gs [i], it's going to associate
the axes and return it. So that actually creates the axes underneath and then
we're just putting it into this list so that we can access that axes easily later. Now we could actually get that axis out of
the figure itself. I wanted to do this
just so that there in order and then
uncomfortable with them. More complicated layouts the ordering might
become an issue. All right. Now we just iterate over every item in the directory. So for i in range
len(directories), we're going to determine
the directory name. We could actually get
this out of the keys of the directories dictionary. Then we're going to plot
that item with Squareify. So we've got a single
directory and now we just call the regular
squareify.plot. We're going to pass
in our particular and direct Squareify to render the given axis
objects with GridSpec. So we just call squareify.plot
and this is where everything being built on Matplotlib is actually
quite powerful. So we send it a list
of all the values. Remember these are our
boxes. These are numbers. These are our file sizes. So that's going to determine
the ratio and side of boxes. Then we pass in a list of labels. So these are actually just all
of the names of the files. But here we can pass in
ax and that's a link to the axes or a reference to the axes that we want
Squareify to render to. So it's going to constrain
what Squareify actually does, how much room it's got. Then our color, we've also got this directory colors that we created and so we can associate
those with Squareify. Then we'll set the name
of the axis and hide the axis details to make
it a bit more readable. So we'll just set the title
and we'll turn the axis off. Let me execute that. Now that looks a
lot like a Treemap. Sure it took me 70 lines of code to write about it
and hours of digging through how Squareify
worked as well as learning a bit more
about color spaces than I wanted to and yes this is a pretty limited
looking Treemap. It's one big strip and
we haven't rendered anything there that
might be too useful. I also carefully crafted some of the defaults to ensure
the code would work. For instance that
there weren't too many files that would
make it unreadable. But hopefully you can see the
two points of this lecture. First, a Treemap as an exploratory technique because a lot of power that you can represent hierarchy and
two other variables color saturation in this case and the size of a file all at once. But that the Treemap
does suffer from some usability issues as it scales which we saw in
Ben's nucleotide example. But really the second lesson is that with the knowledge
of Matplotlib and a determination to dig deeper
you can start to create your own visualizations which are tied to your needs in your data. Who knows, maybe you want to fork Squareify and turn it into
a real Treemap library. I think that would be great.