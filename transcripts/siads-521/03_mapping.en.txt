Capturing physical
landscape traits in a written form
is perhaps one of the oldest and most
common examples of information visualization
still in use today. Geographical
information systems or GIS systems are highly
specialized and complex, and made up of a myriad of
unique techniques and tools. In this lecture, I
want to dip our toes into this world and show
you how you can leverage GIS systems to lead to insight in computational
narratives. Let's start with
bringing in a few of our common libraries, we'll bring in Pandas and NumPy, and we'll bring in Matplotlib, the scripting interface pyplot, and I will setup Matplotlib
like we do in most others. So we'll set it inline, and I'm just going to set some of those defaults that we've seen. So I'll bring in
MPL, the top-level module and set the figure size to something that's
a little nicer. So the first bit of data
that I want to share with you is a single session
of running data. Actually this is a small piece of data from your
project data source. So let's read it in
and take a look. So I've saved that in
a file called run.csv, and we'll just bring it in
and look at that DataFrame. Okay, so this data is made up of a latitude
and longitude, a timestamp on what looks
to be second frequency, as well as power in watts, and heart rate in
beats per minute, and an enhanced altitude
probably in feet. I think that the
first thing that we need to consider when mapping, is this longitude
and latitude data. Now these look like
really odd numbers and it turns out that
this Data Source is trying to capture the
maximum precision possible in an unsigned integer. So we need to convert these to a more traditional
decimal format. To be honest, I don't really know anything about this data format, but a little bit of
Googling suggests this is easily done by multiplying
by 180 degrees, then dividing by two
to the power of 31, so let's do that. So we're going to create a new column position lat degrees, and we'll just equal to the
position lat that's coming right off the Garmin
device in this case, times 180 over two
to the power of 31, and we're going to
do the same thing for the longitude values. Now it turns out we're not
really done with this. You see the earth is roundish, but we're going to
try and look at it on the screen which is flattish, and my wife she has a Physical geography degree and she gave me a mini-lecture on all the great and awesome
ways you can take global positions like
longitude and latitude, and convert them for display
on flat things like maps. I'm going to save you
from all of that. Feel free to look
at map projections on Wikipedia if you're
really into it, and I'm going to tell you
that we're just going to use the Mercator projection. Even better, I'm
going to share with you the code to convert
from latitude in degrees to a flat
Mercator projection which comes courtesy of
the OpenStreetMap effort, and here's the URL to
OpenStreetMap.Org. We're going to use
OpenStreetMap a lot today. So I'll just important math, we'll create our lat to y, and we're just going to use
this nice equation here, and we're going to
create a new column. Df position latitude
degrees Mercator, which is just this
function applied to it, and that's going to make
it easy for us to plot on a flat Mercator projected map. Lastly, let's drop anything
with missing values, and this is a simplification
for the moment and might not be what you want
to actually do in practice or in your project. So we're just going to
willy-nilly drop all NA's, and let's look at the
head of that DataFrame. So the first approach I want to show you is probably
the most simple. The gist is that
we're going to render an image behind an Axis object, and then just use
our regular plotting on that Axis object. For this to work, it
means we need an image, and we need to know the
coordinates of the image bounds, and then we can set
what's called the extent, which represents the
bounds of the map. This means that our image behind the Axis
object will be using the same coordinate system
as the Axis object itself, and the plot will be locked. Okay, so first image. I got mine from an export from the OpenStreetMap and
saved it to map.png. You could get a map directly
from their website. I actually ended up using one of the other exports sites
that they link to, and to display this
we're going use the pyplot imread function
and pair it with imshow. So we can just read an image in, and this just reads an
image from a series of bytes into an array. So we'll use the plt.imread, and then we'll use imshow, and the parameters for imshow, you can look up the
details of it but we pass in an image that's been read
in like bytes like this. We put it in an alpha channel transparency if we wanted to. I just specified 0.5
To shade the map out a little bit so that
it's not so in your face. Then the extent, and the
extent is really important, and so these are
longitude and latitude coordinates for the
bounds of the map, and this is essentially going
to set those axes values. Let's take a look. Okay, great. So that created the map, and we can see that
the x and y axes are constrained by the
extent that I set up. Now the extent doesn't
really matter. You can choose whatever you want. You just have to make
sure that it aligns with whatever your map is. In this case, I looked
for the min and the max of my different
fields in the data, and then I went to OpenStreetMap and found a map that at least covered those bounds
because I wanted to show the whole set of data. Now it's actually really easy to overlay our data
on top of this plot, and we just use whatever
plotting function, already exists in pyplot
that we're interested in. In this case, I'm going to
use one called scatter. I'm going to add in
a colored bar as well and change
the values of dots being plotted based on the
power column in our data set, and you've seen most
of this before. Okay so we didn't turn off
that image closing in Jupyter, so we have to re-show the image. So I'll just copy and paste
that line for plt.imshow, and then we're going to
plot our longitude and the Mercator projected
latitude data. We can set the series of data
we want to be the colors of points using the c parameter
in the scatter plot, and we can choose from
different color maps using the c map or a color
map parameter. So we'll just do plt.scatter. So we're just telling
pyplot that we want to make a scatter plot on
the current axes. We're going to pass
in our two latitude and longitude values, and then we're going to set
the size of the marker here. I'll just set it to five pixels just to make it show
up a little better, and then we want to indicate
that c equals df sub power. That's just saying that I want the colors to come from
that power column. Now those are all just numbers. Underneath, Matplotlib
is going to do all the interpretation of what those colors
should come from, and what it's going to do is it's going to look up a color map. In this case, I've given
a c map version of blues. There's probably 25 different
color maps out there, and you can create
your own color maps if you wanted to for instance, then our range of
colors and Matplotlib is going to scale those c values, so df sub power to choose from that color map and give
us a nice gradient. Then you can set the alpha channel transparency on the scatter plot as well, and I'll set that up here to make it a little bit lighter. In part, because I want to see when points overlap one another, I want it to become
an even darker blue. So now we get pyplot and
we're going to ask it to render a color bar so that we know the meaning
of these colors. So to do that we just
call pyplot.colorbar and nicely it returns the color
bar, so we can also say, dot set label on it and set it, and here I'll set it
to power in watts, and then I'm going to add
a meaningful title too. So I call it plt.suptitle, and I'm going to tell
it that this comes from the earliest timestamp to the latest timestamp in our data, and I'll just add a little
formatting here as well. All right. Nice we have a map and we have some
points plotted on the map showing the
various power measurements and if you look at this, you'll notice that many of the power colors look
basically the same. So what's going on here? Well, notice the
color bar range goes from about 100
watts to 400 watts, and it seems that we
have some outliers. Low power points
which are skewing these automatic coloring
and I think you should probably have
enough skills now to change this and so
here's a challenge. Why don't you just
pause this video and see if you can
find those outliers, get rid of the outliers, or scale the outliers
and update this plot? Okay. For the second approach, I wanted to see if we
could actually bring in altitude data as well
and so we're going to look at a 3D plot and you've seen NEA do these in
a previous lecture. So let's import our
3D axis object. Now, let's generate this 3D
axis object to work with. We can do this by calling the get current axis function and
setting the projection to 3D. So I'll create a new figure off pyplot.figure and then I'll get the current axes and I'll say I want it projected into 3D and that'll trigger this
axis 3D toolkit to fire. So here, I've captured the return value which
is this 3D axes object. In this axis, a lot
like the axis object, but because it's
a 3D axis object, pyplot convenience functions
like scatter aren't immediately available
but the process is basically the same as before. Just make sure that there's a third piece of data
the zed direction which we add from the
DataFrame and we'll use the enhanced altitude column. So here I'm going
to call ax.scatter. I'm going to parse
it the longitude, the latitude, and this
enhanced altitudes. This is a new parameter
and then I'm going to set the value of the
markers to size five. I want the colors
to still be df.b power and I still want
them to come from blues. You'll notice that I captured the return of the scatter
function as well, which I haven't done
before and this is actually a list of artists. This needs to be sent
to the color bar. So the color bar knows how to calculate the range
of values to show. So then we could
do plot.colorbar, parse the artists
that were returned by the scatter plot and then
set the label to watts. Okay. So let's set
up some axis labels. I'm going to have an
x label, a y label, and a z label. All right. Next, we can see that
the long tail is at a lower elevation than the
movement at the top which fits with the personal
information that I have about the location since I happen
to know it's up on a hill. One more example before
we leave this data. It would be nice if we
could see a range of different projections in this
three-dimensional space. One way to do this is with the matplotlib
animation routines. So first, let's set
up our 3D axis again. So we'll get a figure from pyplot and then we'll
project it onto 3D. Now, we're going to define an initialization function
and this is going to render the initial image and return a set of
artists to render. So this is pretty easy. We just call it whatever we want here. I'll call it init and then, we'll call the
scatter plot function with three parameters. I won't add all the
extra stuff this time, I'll just add those three
parameters and keep it simple, and then we'll return all of
the children of the axis. So this is a list of all
of the artists that are in the axis to render and that's
an important piece here. The animation routines
for matplotlib needed to look through these children
at each frame of the video. We need to define a function
which also updates the view. In our case, all
we're going to do is rotate the camera a bit. This is done with the
axis view_init function, which takes two numbers
determining rotation. Each time a frame is called, our update function will be
called with some content. In this case, we're going to
make the content just one of those parameters of view_init. So hopefully this will
a little bit more sense as we build it out. So we need init function. I'm going to call it
update view and it takes one parameter and that parameter we will get to decide later. But here, we're just
going to have it a number somewhere between zero and 360. We'll call it frame. That's just which frame is being
rendered to the screen. So we'll start at
zero, then we'll go to one, then we'll go to two. We're going to rotate our image. The way we rotate it
actually is pretty easy. We just call the axis object.view_init and
this is assigned to this 3D axis object and the first parameter
is our up-down. So we'll give that a 30. A nice 30-degree view of our data and then
we'll just pass in the frame and so the
first time that we call this it'll be
zero and by the end, we'll have gone 360 degrees, and then we just return all
of the children of the axis. So it's actually
quite simple function and this is going to be called over and over again with new frame numbers to actually
build out that animation. So to start the whole process, we need the matplotlib
animation routines. So from matplotlib, we'll import animation and now we can set up the function which
we'll call everything. Notice that I'll
provide a list of frame numbers from
zero to 360 degrees, but I'm going to do it in
three-degree increments to make it a little bit faster. Each item of the list
will we parse through to my update view function
after some time interval. So we can really
build this list of frames information
as whatever we want. Whatever data we need
to send to update view in order to have it change. So I'll call
animation.funcanimation. So this comes right out of the matplotlib animation library. We parse in the figure which has just the only
figure that we have. We parse him the function, this callback function that's called which is the update view. Then we parse in
the initialization function too, which init. I'm going to set the parameters now is essentially the frames, the list of data that should
be called the update view and here I'm just going to use an inline list comprehension. So I'm just going
to go from zero to 360 in steps of three
and create a list of integers for that and then the interval is a
set amount of time. How much time do we
want to wait between each frame when we're
building out that animation. The last step is that now we actually need to start this
and render to the screen. The simplest way
to do this is with the Jupyter HTML function, which displays some HTML. Then we can start anime
running and we can generate an HTML5 based video. So from ipython.display we import HTML and then
we just call HTML and we just say anim.to.jshtml that generates a
JavaScript video. We could also create a savable
video like in a.mov file with.save or we could create a video with the HTML five
video option as well. So this takes some
time to render. You should note that
it's still very young in Jupyter's Ecosystem,
some of this data. But at the end, you
should get an image, our 3D image showing up and there'll be some basic
JavaScript controls to play that image or step through
that image and you can rotate it as you
playback and forth, and in this way, you can build
a visual representation. You might see if you play with
the scrubber a little bit, you might be able to find
out what was happening with some of those
missing values. I don't know that it's
easy to see here. So while it takes
a while to render, it's because matplotlib
actually has to run through all of the
frames and write them out to a JavaScript
file to actually embed them in the browser
which is managed by Jupyter, and this part of the
ecosystem is pretty raw actually and it could use
a little bit of tweaking, but it's handy to also
have a save function for building animations
that you might want to go to afterwards. While the first frame is rendered statically on the page
as well as the video, I'm actually not sure. If you happen to find out why, feel free to let me
know so that I can update this lecture and
let other people know. It might be nice if the
video could also look through a few different
camera angles as well. We set it to 30-degrees
intentionally here, but maybe there's a
second value that could be parsed into frames
to iterate on. Why not pause this video
and give it a try yourself? So this method of
creating a map using an image with extents
is simple and reliable. Though it's maybe not as fast and seamless as it could be. An alternative approach
taken for maps in web systems is to
use a tile server. Note tiles servers
actually create a matrix of maps at
different zoom levels, then serve up portions of
those maps which we'll call the tiles as requested from the client and this
is how Google Maps, for instance, works and it creates a response experience at the cost of being a bit more fragile as network
access is needed. This paradigm is
also available in the Jupyter notebooks as
well through a project called leaflet and
this project is all client-side JavaScript and it does the map requesting
and rendering. To connect this to
our Python backend, we're going to use
the Folium Project, so let's walk through an example. So let's import folium. So import folium and now let's render a spot from
our previous data. For this, we're going to
pick the center point of the map and a zoom level. So I'm going to say folium.map. This is going to
create a map object and I'm going to
set the location, and I'm going to set the
zoom level to 12 and you can experiment with
the zoom level to get a sense of what that is. So [inaudible] I will
notice that I had to reverse our longitude
and latitude for this library
and I'm not using the [inaudible]
changed values for the longitude which were 46. So welcome to GIS systems. There's lots of incompatibilities
between approaches. To display this, we just call the Jupyter display function
and we parse it the map. Okay. So we can see that our map is actually easy to move around, and zoom in and out just because it's just like
Google Maps essentially. So you'll notice that the
user experience is nice, and then you can see the
data is being streamed by the OpenStreetMap project in that lower right-hand corner. We can add colors to the
map using the marker class, and so we can set this
for the start and end. So I got to create that
map all over again. I got to set the zoom
level a little differently to 15 instead this time. We're going to call
the marker class, and we're going to pass
it in, two values. So the first value is the
position in latitude degrees. That's our full DataFrame, and we're just going to
pull this top thing, that first row off. So just I lock, remember this is indexing off the first
integer value of zero. That's just the first
latitude value, we'll do the same thing
with longitude value, and then I'm going to set
a pop-up value of starts, so that when you hover over the little thumb tack on
the map, you get a pop-up. Then key here is we just
dot add to the map, and that adds it to
that collection. We're going to do the same thing with the very last
item in the list, remember I lock users slicing, so we can just grab the
bottom item as well. We also want to map the
whole running route. The docs for folium point to a polyline is the
appropriate class to use. The polyline takes a list of
locations as tuples which means we have to
combine our latitude and longitude values pairwise, and this is actually
easily achieved through the use of
Python's zip function. So here we'll just
call folium.polyline, and then we'll set the
location to the zip, now zip will take in two lists. In this case, it's two
columns from our DataFrame. It's going to take each
one of those items in those columns and merge them with the other
one into a tuple, so that there are two
values of the tuple. So the output of zip with two lists of equal size
is one list of tuples, and not list has equal size. That's the first
tube, and I'll set the weight of the line
as well and the color, and I'm going to add
that to the map. All right, let's render this and get Jupyter to display it. So we see we're zoomed
in a little bit more, and we can see that whole route. So it's pretty nice rendering, we can zoom and look around, and get a nice interactive
sense of our data, and I really encourage
you to give that a try and get a feel for what
this actually feels like. The docs really
demonstrate how to use leaflet to do
interesting things, and they've been
well optimized in the browser in the
JavaScript world, including setting colors for
HTML codes and events even. I'll be honest, I actually
don't know much about folium, and how we might do something like add interactivity through events or show pop-ups to allow for exploration of
individual data points, or even create a short
video which might demo interesting aspects of your map, but these might be
interesting places for you to take your final
project in this class. I'm hoping that a few of you
might decide to do that, and show me something
interesting with foium. Before we leave mapping though, I want to demonstrate one more information
visualization technique that is common in data science
and folium supports it, and this is called
the choropleth map. The choropleth is basically
a geographic heat map, where a map is rendered and then a heat map of geopolitical
boundaries is rendered on top with
colors representing some statistical value
from a data set. So let's read in
some sample data. I picked up this
data from Stats Can, their web site on the provinces, and territories, and
their populations. So I just went and
I just copy and pasted the provinces from Canada, and territories are here too, and set the population values. Then I went to this other
website called QuantHockey, and I thought it
might be interesting to go and take a look at which province tends to train the most NHL players per capita. So as you might know
him actually from one province right in the middle of Canada called Saskatchewan, and we don't have an NHL team, and that's a bit
disappointing to me. We have to drive six
hours to go watch a game live either an Alberto's, So Edmonton or Calgarians, and there the choice is pretty obvious that it's Edmonton, not only because the team is of course way better and
way more interesting, but so is the city or Manitoba, and of course we would
never drive to Manitoba to go watch a hockey game when
Alberto's right there. So here's a link to the
QuantHockey data set, it's really cool. So I've saved this in your hockey players
by province dot CSV. So we'll read that into
a DataFrame as well, and then we're going to merge these two data-sets together. So they both have the same
column called province, so we can just merge on that. Then I want to
calculate the ratio of NHL players by
province population. So this is the per capita
list of how many NHL players a given province exports
essentially creates/. So there we go,
relatively small ratio. You know we have lots
of hockey players but not everybody
is a hockey player. So making this chloropleth
map in folium is actually pretty easy as long as you have a shape file for your
geopolitical regions, and just like different
map projections, shape files are a
huge bag of hurt with multiple competing
specification and details on how to convert
from one to another. To be honest, this is
a mass of time sync, but there's an emerging new
open standard which seems to be available now
called GeoJSON. As the name implies,
GeoJSON files are all JSON coded polygons
with embedded metadata. So I've saved that
Geopolitical borders for Canadian provinces in the cdn.json file on
your file system. So let's start by
making a new map, and we'll zoom pretty far out, Canada is pretty big place. So I'll create a
map, a fully map. I'll set the location
to in the middle, it's hard to really
find the middle of Canada due to its weird shape, and then I'm going
to set the zoom start all the way out to three. Then we're going to create
this choropleth object. The first parameter is Geodata, and this points to our JSON file. Then we indicate the pandas DataFrame that we
want to use the data, and we provide the two
columns where the first is a reference to the
region we want to color, and the second is the value that we want to use
for the heat-map, and this is really
quite nice that it's aware of pandas DataFrame. So this is pandas being
used more and more as just a general data
representation and manipulation like library. We have to specify
a color as well, and then an important
parameter called key on, and this last parameter maps to the features in our
JSON data file. So I'll be honest
that last parameter is a pain because you have to know JSON and you
have to know GeoJSON, and I frankly decided to learn GeoJSON specifically
for this lecture, I've mostly used the ArcGIS
shape files instead, and it took me a little bit
to actually dig through and find out how to
get my key correctly. So in this case, I'm using
feature.properties.name. Hopefully, that'll be more clear if you look
at that JSON file. But as you can see,
actually making the choropleth is pretty easy. You pass these parameters
and you add it to your map, and then you just call display, and let Jupyter do that
heavy lifting for you. All right, there we go. So
there's our choropleth map. Yeah, we see that at
the upper right there's a color bar has been
rendered for us, that goes from my yellowish. That's gritty in my opinion, all the way to through
oranges to a red. We see that there's
two territories in Canada that don't
have any data, so they're shaded out. Unfortunately, the
eye is drawn right to those even though they
just don't have any data. We see the majority there in that first bucket very light, that includes the Maritimes, Quebec and British Columbia
and one of the territories. Then we see that a little
bit more in the West, we have these orange colors, and of course right in
the middle there is a nice deep red one and
that's the Saskatchewan. So I think that this is a really interesting away and interesting approach
to look at your data. Choropleth are very common. You can find or build
your own shape files. So these are all just polygons. The ones for the United
States are readily available always
for the 50 states. Often, you'll want to look at government data sites
for a given region. So for instance Statistics
Canada has them for Canada, but they have them for
the provinces like this, but they also have like electoral
districts and so forth. So this is often where
you can go to look for some sense of truth for those
but you can write your own, the GeoJSON files id pretty simple, they're just polygons. In this lecture, I've
just touched on some of the information mapping
that you can do with geographical
structures and data. We've seen several different
approaches from rendering simple data to
superimposed over our map. So that's the plot that I showed to a polygon coloring
this choropleth. Geographical
information systems or GIS systems are big area and there's hold degrees
offered on this. It's helpful to know
a few things about spatial representation
for data for those times when you
have physical data, and you're trying to integrate
it with other information.