In this session, we're
going to be looking at scatterplot matrices or SPLOMs. SPLOMs are relatively less
common visualization tool, but they are very useful. They use multiple scatter
plots to determine the correlation if any between
a series of variables. The scatterplots are then organized into a matrix making it easy to look at all the potential correlations in one place. When we look at a scatterplot
matrix we are looking for covariance for the relationship that appears to be
perhaps linear, quadratic or
exponential, and for how these features are dispersed
relative to each other. As a data scientist, we should know when certain approaches are
more useful than others. So today we will be using the seaborne library to
construct our SPLOMs. Seaborne is a Python data
visualization library based on matplotlib. It provides a high level
interface for drawing attractive and informative
statistical graphics and happens to be especially useful when creating
scatterplot matrices. To get started, let's load in
a seaborne library as SNS, pandas and Iris dataset, and check it all out using
the first five rows. So import seaborn as SNS, import matplotlib as plt, import pandas as pd. Then we'll load in
the iris data set using the pd reader as CSV, and print out the
first five rows. Cool. It looks like we have four numeric variables and one categorical
variable for the type. Now, if we wanted to just
check out a simple example of matplotlib has as a
built-in function to create scatter plots, which is just called scatter. A scatter plot is a
type of plot that shows the data as a
collection of points. The position of the point depends on its
two-dimensional value, where each value is a position on either the horizontal
or vertical dimensions. Let's see this in action. Plot the sepal and petal width on a simple scatter plot,
like plt.scatter iris. Then we'll say we want our
sepal width and petal width, and some useful visualization
information like the x and y labels and then we
can just show the plot. So this was pretty convenient and we can easily visualize a
relationship here. But if we wanted to explore
the relationship between all the variables in
the dataset at once, this could get very
complicated in matplotlib. However, using seaborne,
it's extremely simple to just create SPLOMs with
the pair plot function. In fact, it's just
one single line. You can pass this
the data frame with some numeric variables that you want and you'll get a
scatterplot matrix. So we'll just do SNS.pair and
then we'll just say iris. By default, the pair plot
function will create a grid of axis such that
the each variable in the data frame will be
shared by the y-axis across a single row and the x-axis across
a single column. The diagonal axis are
treated differently, drawing a plot to show how the univariate distribution of each data for one
variable in the column. So now we can see that
each of the plots in the pairwise relationship between the variables that we
have in the data frame. These visualizations are easy and usually best for no
more than four or five variables at a time. Because after that it gets a bit difficult to understand and
really see the relationships. Okay? So as we can see, we have a very clear
positive relationship between petal width
and sepal length. If you look at sepal
length and sepal width, we see a relationship that
is still positive but not as strong perhaps or as
clear as the previous one. We can specify the
same pair plot and add in the hue argument to
send it the species variable and the data to map the plots appearances
differently and color things differently
based on the flower types. So for this we'll
just do SNS.pairplot, iris same as before. Then in addition to that, we'll add a hue equals species. We can also add in the
palette argument to set the colors mapping
for the hue variable. So we'll do SNS pairplot, iris hue equals species,
palette equals husl. Now, if we wanted to change the diagonal subplots or what appears on the
diagonal subplots, we could just use the
diag_kind argument. For instance, we can change the current KDE subplots
to histograms instead. So we can do SNS.pairplot, iris, hue equals species and
instead this time we'll do diag_kind equals hist.