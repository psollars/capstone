So in the last section, we just
talked about regular expressions, but let's see how they work
in practice in Python. Most of the regular expressions
in Python used the re package, this is actually a really built-in package
that does capture is most of the basic regular correction functionality. It actually covers all of the general
techniques that we've talked about, as well as a lot of fancier
techniques that we did not. So, let think about how we declare a
regular expression, so say I want to match cats, here I've said I will match
cats with the disjunction operator. With the lower case c or
the upper case C and I don't really care what comes after it,
in this case s or any number of times. If you notice, I put an re in the front
and this is the expression for a raw string, it's often helps
Python not escape the kinds of regular expression things
we want to use here. We can also even express something
like a phone regular expression and the re compile we can use to generate
a compiled regular expression object. We can call methods on, that said, most
folks don't use regular expressions this way with compiling them, they said just
call things on the re package directly. Specifically, one of the most common calls
is re search, so here I'll express my regular expression, and then I'll pass
in some text and get a matcher object. And the matcher object actually helps me
try to figure out where the match was found, I want to point out that you should
always check your regular expressions. As we saw in the allies example
in the previous segment, writing regular expressions
can often be tricky, and in fact there's many online
tools that can help. One of my favorites is pythex, which exactly matches
the python regular expression. In particular, I've entered my
regular expression here and I've had a test string that I
can see what exactly matched, so I said cats, cats,
I love those cattsss so much. One of the things I've noticed
is that with that star operator, I'm end up matching parts
of the cats in the bottom. And I said, well,
I don't really want to match that exactly, so instead maybe I'll use that
special word break operator. It says that my word, my match has
to occur right at the beginning and end of a word break, and
I'll add those /b right in the beginning. So, now it only matches
cats with except with the invariant of capitalization
of the start of the word. So the search object itself
will return a match object for the very first occurrence. So if I say re search cats for
some text that was my original impression, we know that we now want to use the word
boundary operator to actually make sure that that only matches cats there. Looking at this in practice, I'll import
the re library and if I have some text called, I really like cats, all cats, big
cats, small cats, but not the movie cats. And then, I search you can see that
I've gotten a match object, that matches the very first expression of cats that
occured at indices 14 and ends indices 18. The group expression can be used to
retrieve the very first expression of that, so matching cats. You can see that if I use another
search for cats in all caps, then it doesn't matter anything because
I have not exactly used that phrase. So in this case the match object is none,
and this let's you use the match object in if it statements to test whether
research was successful or not. If you're interested in more
than one retrieved match, you can use the findall that will return
all the strings that were matched. So for example, if I use the same
regular expression for cats within this, you'll see that it finds all the uses
of cats within my text itself. If you want to see if you regular
expression matches an entire line, you can use the match operator. So just to clarify,
search will find the first occurrence, but match will only return success
if it matches the entire line. So if we try our initial example of cats,
the match object itself will say none because the input regular expression
did not match the entire text. Let's say that we changed it to I
really like.star, in this case, are some text expression string. Does begin with I really like and that dot star says all match
the rest of that until the end. In this case, we do retrieve a successful
match object, so the regular expression search and find all expressions
will always return a match object in. This could be really useful for
doing that if L statements for seeing whether you found a match. But more importantly, the match object
will return access to groups in your search, so as we saw before, these
parentheses can define groups that let us retrieve a specific part
of a much larger match. So match Group 0 is will always return
the entire match, so here in this example, I've shown a regular expression that
tries to match email addresses. And we use the star operator
at the beginning and end to match the rest around the email
address, I put a parenthesis that, let's say match jurgens@umich.edu
in the example text. If I retrieve group 0, you can see
that it matches that whole expression, my email address is jurgens@umich.edu,
you need it. If I try to treat the first group,
now I get just jurgens@umich.edu, which is a useful example of how we
might retrieve interesting information. We can also use these matches with
substitutions provided by the re package, so say for example, I have my previous example of my email
jurgens@umich.edu, if you need it. And here,
I've tried to break up into two groups, so one group will match the part
before the @ sign and the second part will match whatever
is the domain and the suffix. And I'm going to try to replace that
with a substitute of email address, so if I search and re.sub, this will substitute whatever is in
that first part to the second part. And if I run that, it gets my email
address is brackets email address if you need it, which you think it might be
a useful way to find anonymized text. And you can even do this with groups too,
so for example, my email address is jurgens@umich.edu. Here, I've done that same bracketing and
now I'm going to replace, do my substitution string with
parts of the matches directly. So, I'll replace the first match and
the second match or the first group and the second group, and now I get my email address is
jurgens(@umich.edu if you need it. There are many advanced parameters and
to point a few out, one of the useful expressions is it when compiling or
searching, you can use re .ignore case. To say that you don't actually care about
the casing of a particular phrase when you're trying to do a match. It's going to be very helpful if
you're dealing with noisy text or people are inconsistent in capitalization. There are more options for
things about line breaks, especially if you have new
lines in your text and for handling unicode within what matches
the word or other character classes. So, some concluding advice about
regular expressions and Python, one, you should verify your regular
expressions before using them. They're often many kinds of surprises, and sometimes they're tricky
to write exactly precisely. So, I encourage you to use online tools or
the Python interpreter or your favorite Jupiter notebook for
testing these out before deploying them. You should also figure out if
you're working with ASCII or unicode data,
as you'll need to make sure that you can match unicode characters if you
do a spectrum in your data set. And finally, many regular expressions
can achieve the same goal, so if you're going to use these frequently or
within a hot loop in your code. It's actually useful to maybe try
to benchmark to figure out which one it might be fastest.