Welcome back. Today we're
going to talk a little bit about one of the most powerful
ways of analyzing text. You may see regular expressions
in many different areas, including your UNIX command
line class as well. But I want to give you an
example of where they use an NLMP using a chatbot. This is the famous chatbot that's a Rogerian therapist
known as Eliza. Eliza typically starts off
by asking the patient, you or me, please tell me
what's been bothering you. Let's say that a person says, "Parents are all alike." Eliza responds, "Could there
really be some connection?" You say, "They're always
bugging me about something." Eliza responds, "What incident
are you thinking of?" "Well, they made me talk to you." Eliza responds again, "What
are you feeling now?" "Well, they say I'm
feeling depressed." Eliza responds, "Thanks
for coming here. Do you think coming here will
help you not be depressed?" Is this advanced
chatbot technology? Could be doing therapy using some advanced natural
language processing system. It looks like Eliza is
responding and reacting, mirroring the
language of the user. In fact, this is not, this is actually an old
chatbot from the 70s. Even though it seems
very sophisticated, what's Eliza really doing? Well, for one thing, Eliza is trying to mirror the language. If a user says, "I feel y,"
Eliza might respond with, "How often do you feel y?" If you say, "I want y,"
Eliza might respond, "Suppose you got y soon." Or if y, Eliza
would respond with, "Do you think it's
likely that y?" These types of
reflective language help Eliza seem like it's
listening, an active listener. Some other tricks involved
in converting "my" to "yours" and to randomly produce a subject chain if
none of the rules match. But as a whole, Eliza is
using this pattern matching system to try to create an interactive
chatbot experience. How is Eliza making
these matches? For one thing, Eliza is
about finding patterns. Of course, users can type
many different things. Humans are endlessly
creative in what they type. We really need a system for expressing many different
general patterns. One of the powerful
techniques for doing this is what's known as
regular expressions. You'll see this beyond NLP. It's actually one
of the most useful techniques to learn early on. Why do we talk about
regular expressions NLP if you've seen these before?. Well, for one, it's really
useful for doing things like searching for a new
linguistic phenomena. Do you ever say, use the verb consume
followed by news, we're thinking about what
things do people say consume? Another useful thing
is for creating features for
supervised algorithms, and we'll talk a lot about
that in this lecture later. It's useful for morphology, for thinking about how words
might vary in their endings. We'll talk about that. Last, we can also think about
regular expressions as a tool to help thinking about the structure of
language at the word level, especially through the
morphological aspects. Let's think about
the different types of operators for
regular expressions. One of the most common operators is what's known as
the disjunction. First, let's give you example of a regular expression,
say "woodchuck". Any string itself is
a regular expression and that only will
match the exact string. But let's say we want it to match two different words,
Woodchuck and woodchuck, they're different in the
capitalization of that first w. The disjunction operator, this closed bracket or
the square bracket, lets us specify multiple
matching characters. Here we have two Ws and that will match
both of our woodchucks, the examples earlier,
ignoring the capitalization. We'll call the thing in that bracket operator
a disjunction. We can actually specify
ranges of disjunction using the dash character within
the disjunction operator. Regular expression
libraries typically know something about
the order of letters. If we say a-z, well, that's going to match
every letter from a to z. Or if we said a to g, that would be a all the way
to g, but nothing after. We can also use negation
and disjunction. Sometimes we actually don't
want things to match. Here are two examples
where I said, "I don't want to match
any capital letter." If we see on the
example on the right, CCl is far, that lowercase i is the first
thing that will match. It won't match any of the other three capital letters before. Similarly, I've used a
capital S or lowercase s in my disjunction operator, and that will match the i and SI is far now as the
first type of match. We can use the char, when it comes after. If I had this funny
emoji looking thing, this will match neither
o nor the care operator. Essentially that will match everyone that's here now, the e, that first e. If we don't put this char in the
disjunction operator, well, it's treated
like a raw string. If you say the string ab
and we say logic uses ab, well, that's going to also
just match that string itself. Another way to express
this disjunction is through the pipe or that
vertical bar character. Here we can actually
express soda or pop. You can see how you might use this regular expression
say to match known things that you don't
care which one appears. We can also take a
regular expression like a or b or c with that
pipe operator. That's the same as
expressing a, b, or c in the bracket
disjunction operator. We can even combine them. Say if we don't care about the capitalization of soda
or pop in the beginning, we can combine them with the or, and we're going to actually
match more words this way. We can even use the pipe within the disjunction operator
if we do want to say match s or the pipe character or p. There are many other
different types of operators, and disjunction is one
of the common ones. But another one is the
question mark operator. But let's just say that something is an optional character. This is often useful in natural language
processing when you want to match certain things but have variants in British spelling. If you want to match
color with the u from the British variant or just the American Standard
English variant. Another powerful
operator is the star, which will match zero or one
to the preceding characters. Here we could have
cool with two ls, we could have cool
with any number of ls, as long it has at least two. If you want at least one, and this is often an alternate
way of using the star, we can use the plus to say that I can have any number
of these characters. We can combine this with
this disjunction operator here to say that as long
as you start with co, you can have any combination
of Os in a capital or lowercase and then followed
by an l. So we can match, cool, cooool or coooooool. Another operator is the dot. This will match any character. If we say beg.n, that string alone will
match both begin, began, begun, and began with some
leet speak like spelling. If you care about the
particular number of times that match should occur, we can actually use the
curly brace operator with the disjunction operator to specify how many times
that might happen. Here in this first example, I've shown you the cool
has to occur with a co, followed by anything
in the disjunction exactly two times. This doesn't match the
correct spelling of cool, but it will match
cool with three o's. If we use the M, N, we can actually specify a range. Here we'll specify cool that's correctly
spelled, to cool, to all the way with four o's, but not cool with five o's. One of the ways you can get the most generalizability out if your regular expressions is to use what's known as
character classes. These are specific
classes that will match different
sets of characters. For example; you can use
\d to match any digit. If we say I want to look
for any date in January, I could say Jan \d plus, and that will match anything
that has January with a number that occurs
at least one time. For many of these, there's
often a complimentary class. If I say \D, that'll match any character
that's not a digit. If I say \D plus for
the same example, that will match all of Jan, but also the space since the space itself is not
considered a digit. If you care about whitespace, the \s operator or character class is a
really useful thing for saying I care
about say Feb/s, so any number of spaces,
followed by a digit. This can be useful if
you're dealing with, say, noisier texts with
nonstandard spacing or a users may vary in
how much they use it. The compliment class,
\S is not a whitespace. That essentially will
match any character that isn't a whitespace break. If we care about work breaks, the \b character class is
actually a special one. It doesn't match any
particular character, but it enforces that the
pattern that we find has to occur at the end of a word boundary or at the
beginning of a word break. \bfoo\b will match
foo, but not food. This often is really useful if the thing that
you're looking for is often a sub-string of another longer word
that's very common. I should also mention that many regular expression libraries have even more character classes. It's often useful to
think about what they support when making
your own application. This can vary by
language or even by a regular expression
library within a language. It's
useful to take a look. There's one more example; anchors let us specify where the position of the
match has to occur, specifically relative to
the beginning or end. The caret, when used outside, will match the beginning
of the string. If you say caret a-c
will match that first c, or if you say caret, and
we use that caret inside, that's the negation
operator, let's say, matches anything that starts at the beginning of the string; it doesn't occur as a sequence
of lowercase letters. Similarly, the dollar sign operator is the
end of the string. We can use that to match things that occur
at the very end. If you notice, in
the first example, I've escaped the period; so this treats it
as the dot and not the special anything operator. Let's go back to our original
example of what's ELIZA doing to get it one or more powerful features of
regular expression. ELIZA itself is trying to match a particular thing that is found within the
user's statement, and then to reflect it later. One of the ways that regular
expressions try to do this, to find a specific type of match, is what's known as groups. Groups allow us to reference a part of the
matching expression. We're going to create
a group by using the parenthesis around
a sub-expression. Say, you had the regular
expression, my name is, parentheses, and then
some combinations of lower or upper case letters. We would say that
the person's name is captured by that first group. We could actually
reference these using a special operators
like \1 or \2, but that said, I should
also point out that these group references can
vary by programming language. It's actually useful to check how exact they need to
be referred to. They can also vary
by library too. If you use a different
library within Python, you may have to take a
look at how they work. Let's take a look at some
simple code to build our ELIZA. Here, I'll show you
the main function. Then this while True loop, it's going to read it in a statement that
the user has said, and then it's going to
call the analyze function to try to generate a response. I don't want to go
into all the code, but the analyze statement
has a few key things. In the middle, it's going
to try to look over all the different types of
psychobabble responses, and try to match
some pattern from the user's statement to
generate its response. Let's take a look at what
that psychobabble is. Here, we're going to
see something like a pattern that is going to be matched from what
the patient says, or in this case, the user. Then it's going to
try to generate a response randomly
from one of these. You can see that
there's \1's here, which are going to be what
the group gets matched to. There are many of these. To look at a few examples
here, this is say, if the user says friend, and that can be preceded or ended by any other type of content. To show another slightly
more complicated example, here is; why can't I? With a series of
question mark operators. If we walk through this, you can see that the question mark itself is escaping a
single apostrophe. This is perhaps an example of where regular expressions
can be used to capture or guard
against the type of robustness to variability
and whether it, say, users are noisy
making apostrophes. Similarly, that second
group at the end, the last group, is
trying to match anything that doesn't match question mark. You can see that
the question mark itself is in that string. Then itself, the
last question mark is also escaped with a
question mark operator. If this looks slightly
confusing to you, it's a good example
of how you want to check your
regular expressions. Often things like, I want to
match anything that's not a question mark and when you added a few more
robustness checks, it starts to become
very complicated. It's useful to
check these things. Just to point out, this /1 here is a rate matches that
regular expression group. In the first example of I need dot star that will
match any content. Then we can capture
that first thing that the user has said that they need and replace it in the end. With these kinds of
simple expressions, we can actually simulate a
Rogerian Therapist with ELIZA. It was often good enough to
fuel several of its patients. Regular expressions provide this powerful language
for doing these types of matches that you use
both in NLP and beyond.