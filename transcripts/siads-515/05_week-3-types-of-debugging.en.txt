Okay, so let's talk about
the different types of debugging. In this course, we're going to talk about
print debugging, interactive debugging, and I'll mention post mortem debugging,
which is sort of a form of interactive debugging that happens
after the program crashes. There are other techniques,
I don't want you to think that this is a comprehensive list, there
are other techniques that we can use. In print debugging, we use print
statements to indicate code flow and variable states. Let's go ahead and
take a look at that in the notebook. We've actually been doing print
debugging throughout this notebook. So every time I've done things up here,
for example, for r in g. So this is horrible naming, and
I would want you to use better names. But for every row in our generator,
that's what r in g stands for, we're printing out r. And if you take a look
at our output here and take a look at the size of this scroll
bar, you'll see that we have thousands, hundreds or thousands of values
that we're printing out. In general, this is not a good idea,
but this is what I'm doing with print debugging, I'm trying to look for
things that are anomalous for me. So here in my printing, I notice
that I have weird quotation marks. So I notice that these were strings,
that's what prompted me to CSV DictReader instead of just reading
the line and splitting it on commas. If you find yourself putting
print statements in, for example, here, I might say I might want to do print (line) and run that. And what I find is that I get
a print statement of the line, so I can start examining the variables here. So I know that these are what
my variables look like. So when I'm yielding out subscript one and subscript two as latitude and longitude,
I know they're roughly right, so that I could introduce
more print statements here. I could do, instead of up here,
I could say while true, I might want to be interested in looking
at the value of first, for example. And then I see that it's
true the first time through, false the second time through,
false the third time through, and so on. So that's an example of print debugging. Print debugging is very common in Python. It's quite inelegant and it comes with its
own set of problems because you then have to strip out the print statements. You will also notice when you're
working with large amounts of data that sometimes you have a very large
amount of output to your notebook. That will slow things down, that will
make saving of your notebooks very slow. And in general, it's not a good idea. So one tip here is to always try to remove
the output of very lengthy print blocks. Otherwise, it can really
mess up your notebooks. So let's talk about interactive debugging. Now, I somewhat maligned print debugging. It is very common, and
it's common for a good reason. Interactive debugging is not
all that common in Python, and especially not in Jupyter. The interactive debuggers, pdb,
Python debugger, and ipdb, interactive Python debugger,
are really difficult to use. I don't recommend using them. There's a relatively new technology
available called pixiedebugger, I believe it's created by IBM. When we talk about, and we'll talk about
what that looks like in the notebook in a minute, I need to introduce
some concepts to you first. For interactive debugging,
we have five different things we can do. We can step over a statement, that is,
jump to the next one, step into it, that is, to go down into the stack
of calls to other functions. We can step out of it,
that is, to pop up the stack, we can set breakpoints, and
that means that we can tag lines of code where we want the execution to
pause so that we can examine things. And then we have the concept of
resuming after we hit a breakpoint. pixiedebugger is part of
the pixiedust library. So you can Google for
pixiedust and pixiedebugger and find out more information about that. pixiedebugger is a visual
Python debugger for Jupyter. Let's take a look and
see what that looks like. So we're back to our notebook here. And for pixiedebugger, we're going
to set things up for ourselves. We're going to import csv,
we're going to set up a file name, and we're going to set up some code,
just like we did a little further up. When we run this code, Everything looks like
it's working just fine. We've got our print
debugging going on here, so we see our tuples coming out, right? Let's take a look at our code again. So we're going to print i, we have a print
statement within our function here, so we're going to print that latitude and
longitude out. And then on the outside where we actually
call read_lat_and_lon_with_reader, we have a print statement,
that's why we have the double prints here. So you can see why this is
getting a little bit complicated. And you might think that this is actually
ran because there's a lot of output. It turns out,
when you get down to the bottom here, we have a value error with an invalid
literal for int() with base 10. Now, one of the things you might always
want to do, we've already covered this one, but you might want to go ahead and
Google for that. If you Google for that,
you're taken to a Stack Overflow page, where someone has reported
the same problem. The nice part about working with Python
these days is most of the problems that you encounter, odds are someone
else has encountered the same problem. And then you'll have some answers here. So here we have someone who has
encountered a similar problem. There are different ways
to solve this problem, to cast them to ints,
to cast them to floats. So we get the idea that we want to do
some sort of casting with our number. So let's go back to our code here and
see what the problem is. So it says, an invalid literal int() for base 10: 504675542. And look at that,
there's a semicolon there? How did that get in there? So Googling for that error told us
that it might be some sort of float or casting problem, but it turns out that
there's some problem with our data file. Now, earlier in this lecture,
you heard me talk about data debugging. This is a great example for where we might
want to go ahead and debug our data. We don't know quite where
this value exists, 5046772, but we could certainly
go in through Jupyter. I'm going to make this a little
bit larger so we can see it. So let's go ahead and open up that data
file, it's file ride_final2_extra. And we can go ahead and search, just using
our plain old search, for a semicolon. And we find that in line 29, we have somehow substituted
a semicolon for a comma. One way of dealing with
that is to summarily dismiss that semicolon and
put a comma in there. If that's the only one, then that's great,
you've just debugged the data. But let's say you're a little bit more
worried or a little bit more meticulous than this and you suspect that this is
going to happen over and over again. We know that it doesn't in this case,
there's only one match for a semicolon here. But let's imagine that you were told
that there were several hundred or several thousand semicolons here. As you know from your other courses in
data manipulation, data's often messy. So we're going to have to clean this up or
somehow deal with this. So let's go back to our notebook
here where we hit this error, down here we have a value error. And we couldn't convert that
integer because when we tried to interpret that value, it didn't understand how to split this
on a comma because there were no commas. And as I mentioned here,
there are a couple of ways to proceed. We can fix the data file,
that was option one. And you can think about, and
I want you to think about, under what circumstances would
each of these be more appropriate. The other thing we could do is to
write a more generalized routine. So here we're going to use numpy. We've used numpy in the past,
I think, in other courses. And we're going to get a little bit
more complicated with our logic. We're going to redefine
read_lat_and_lon_with_reader. Exactly the same code,
except now we're going to put a try and except block in here,
where we're going to yield out this tuple with a couple of integers that
correspond to latitude and longitude. But we're going to wrap
that up in a try and except block, because that's
where the error was being thrown. If we hit an exception,
that is, we hit an error, we're going to yield out a numpy nan,
which is not a number, instead of terminating
the execution of the program. So let's go ahead and run that. And now,
if we look at the output of that, again, with all the cautions about having lengthy
outputs here, I'm just doing this so you can see that we run down to
the bottom of the file without an error. So let's now take a look at
how we can use pixiedust. Let's define a new function. We're going to import random because we're
going to need some random numbers here. But the function that I want to
look at is called find max, and that's going to take a list of values. And as you can probably guess,
what we're going to do is try to find the maximum value
of the values that were passed in. And we're going to say we're
going to initialize our max to 0, we're going to take a look
at each of value in values. If our value is less than our max,
then we're going to reset our max to our value and
we're going to return that max value. So if we go ahead and do this with
printing a random sample of values in the range of 100, and
we're going to print ten of them. Well, let's see what that does first. Go ahead and grab one, two, one, two,
just so you know what I'm doing here. If we print something like that,
Too many, too many brackets. So we get a list of numbers
like this if we run this again. So what we're doing is we're printing out ten numbers in the range of,
I think, 0 to 99. So that's what it looks like here. When we call find max on it, though,
we see that it always returns, no matter how many times we run it, 0. So something looks like
it's not going right. I know you might spot the problem if
you're a really good programmer, but let's say that this is something much more
complex, just a simple example of it. Let's actually use some pixiedust and some pixiedebugging to find
out how to make this work. Don't worry if we're not
running the latest version, 1.1.17 is pretty close to 1.1.18,
so let's not upgrade that. So let's run this with
a little bit of magic. And remember we talked about magic
commands last time a little bit too. So our magic command here is
%%pixie_debugger, and then we're gong to include just exactly the rest of our
routine that we did in the previous cell. So when we run this, we see something that looks a little
bit different than we've seen before. So instead of output,
we get something that looks like this, this is the pixiedebugger. And we have a series of functionality here in these buttons that are listed across
here, let's go through each of these. So we have run, we have run the next step, step into, step out of, so
that will go down the stack or up the stack, and also we can
examine values up or down the stack. What you can see here is that
pixiedebugger has wrapped our initial function
with these extra lines. So our initial code down here
starts with import random and ends with print down here. It's inserted these
three lines at the top. So it's created a new
function called pixie_run, that's what pixiedebugger
will actually call. It will import for
us pdb and set trace on pdb. So that allows us to
use the Python debugger without getting to get into the details of
it, so it's a wrapper around it for us. Now, we know that something is going weird
with this function because no matter what values we provide to it,
it's always returning 0. So let's do something that asks us
instead of printing out the values, that's our print debugging
way of doing things. Instead of doing that what we can
do is go out to the margin here and click to create something
called a breakpoint. So you see this little bug here that's
red, if you can see the red, is out here. And that means that when I run this,
so I'm going to go ahead and hit that run button, that it will
actually stop at line number 8. So it tells us down here that it has
stopped at line number 8 in find max, and the line is if val is less than max. Now, what we also have over here, now
we've run and we've hit that breakpoint here, is we have the values of values,
for example. So the values that we passed in are 82,
93, 79, 67, 46, 41, 34, 74, 20, and 27. So I clicked on there and
got these values. Our max value is 0, our val is 82. So we know that if we're
doing things right, and we can also evaluate these here, right? We could actually say
what's our value of max? It's 0. What's our value of val? It's 82. What's our value of values? It's this list. We can also see what
the breakpoints are here. So if we go back here and
we take a look at that and say, ha, well, that's interesting,
we've got a value of 82 and max 0. So what's happening here? If val is less than max, so
val is not less than max, so we're not going to reset the value. Wait a minute, there's my problem. My problem is that I have the wrong
inequality operator here or the wrong conditional here. So it should be if val
is greater than max. So you see, if I loop through this again,
our next value that we're working with is 93 ,our max
is still 0, so we haven't set that. So I've been able,
through the pixiedebugger, to detect that the error
was in my sign here. So I'm going to stop my pixiedebugger, change this to the correct sign,
and rerun this. And now if I set that
breakpoint again down here, and run up to my breakpoint, I see that max. In this case, my values are a little bit
different because I'm using random numbers here, yours will be different too. You can see that in the first
time through, my max is 0, the value that I'm testing is 73. If I run that again, you see that
my max has now been set to 73, so this has worked properly. The value that I'm currently
considering is 25, well, that's not greater than the max, so
it's not going reassign the max value. If I run this again, the value that I'm
testing is 85, my current max value is 73. Now, the next time through,
that max value has been reset to 85, the value that I'm testing now is 39. And I can keep doing this over,
and over, and over because all those values are less. 97 should reset that value and
98 should reset that value. And then I'm done, so it exits by itself. So that's a very quick
introduction to pixiedebugger. But I also want you to keep in mind that a
lot of the common things that you want to do have already been done before. So find max, we don't need to define that,
there's already a max operator. So if we run this over and over again,
we're going to get different random lists of random numbers,
we'll find different maxima. We can also use the inspect module,
so we're going to import expect, and then ask, well, where does max exist? What provides our max functionality? And we're told that this is
a built-in Python function. If we did an inspect on get module
find_max that we defined up here, We would be told that it is not built-in,
but something rather that we have
to find in our main function. So that will help us figure out where
particular functions are defined, that's a useful piece of information. The other thing that I'd like to introduce
you to is the double question operator, and that will pull up the docstring for
any given function. So the docstring is information that
is listed typically at the top of the definition of any function in any
Python operator in any Python code, it's supposed to be there. And it will tell you a very
quick help function about that particular functionality. For example, here we could use decimal
numbers, and we can use max to, max takes any type of number here,
including decimals. If we want to find out what decimals are,
we can do decimal, question, question, and
we find out more information about that. So the question, question operator is
really helpful for finding information about different functionality in Python
that you might not be familiar with.