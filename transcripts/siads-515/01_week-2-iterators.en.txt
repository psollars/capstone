Welcome back. This week, we're going to go into
Python and look at some things that may have been
glossed over in the past, but we're going to spend
some time on because it has a lot to do
with efficiency. So we're going to be talking
about iterators, generators. We're going to talk about
some functionality in Jupyter that are
called magic commands, which will be useful
here and in the future. We're going to talk
about decorators, caching, and memoization. I should say that
that is not a typo, it is memoization,
not memorization. So let's start out our discussion talking about iterators, and specifically,
what is iteration? So iteration has a
standard definition. It's the process of traversing
a series of objects, handling one in each turn until there are no more
objects to deal with. The example that
you're probably most familiar with is a for loop, so a for loop represents
a type of iteration. In Python, then, we often
iterate through a list and you've seen a structure
that looks something like this many many
times, I'm sure. So we have a list
of numbers called numbers and then we iterate through them
using a for loop, saying for number in numbers and then we do
something with the number. In this case, we
just print it out. I want to introduce a
differentiation between the concept of
iterable and iterator. In Python, and this is a
specific Python implementation, is that an iterable
object is one that implements an __iter__ method. In Python, an iterator
is an object that implements an __next__ method. So those underscores
indicate that those are internal methods and
they are typically accessed through some
other helper function. Further on our discussion about iterators versus iterable, the iter function
without the underscores returns the iterator
for an object. The next function returns
the next element from an iterator by invoking the
underlying __next method. So iter without the
underscores will call __iter and next
will call __next. Now, It's usually the
case that a class has both an __iter and
an __next methods. But in some cases, they could be implemented
in different classes and one class could utilize the
functionality of another. Let's go ahead and take a look at an iterator in our notebook. So here's some code where
we set up a list of years; 1967 through 1063,
they're not in order. In our first line, we have an iterator we call iter on years and
that gets us an iterator. Then we're going to call next
on that iterator 1, 2, 3, 4 times in print statement, and then we're going
to call it twice outside the print statement. So let's go ahead and run
that and see what happens. So when we call next
the first time through the print statement,
it prints 1967. We call it again with this
statement, it prints 1974. We call this statement, we get 1955, we get the next print statement
and we get 2029. The next time, we call next, in this particular case, we're not printing it, it's just consuming the value 1063. Then the final time we call next, we actually raise an
error or an exception. So this is a
StopIteration exception, which is what happens when we effectively fall off
the end of our list. We can't iterate anymore
because we've it used up, remember our definition
of iteration, we've used up all
of the elements. We don't loop back
to the beginning, we don't return null. We actually throw a
StopIteration exception, and it tells us it's
stopped at line 8. We'll get into debugging
a little bit later. But for now, what's important
is that we see that last next has raised an iteration,
a StopIteration exception. We know that because this is what our format of exceptions
looks like in Jupyter. If we go back to our
usual example of a for loop and say for a year in years, print year, we see that
behaves as we'd expect; 1967, 1974, 1955, 2029, and 1063. It turns out that Python's for loop is really a while
loop with an iterator. So what we just saw there
for x in some iterable, do something with x. In our case, for number in
numbers or for year in years, we printed that year. Under the hood, it
really is an iterator. So we instantiate the
iterator by calling the iter method on some iterable which invokes
its __iter method. Then we set up an infinite loop, while true and then we
have a try except block. So we try to call next
on that iterator, so we've invoked iter
on the iterable, we have an iterator, and we're calling next, which will call its __next
function or method. We keep doing that and if we encounter a StopIteration
exception, we break. So we try to catch that, we try that line, and then we catch that
exception and stop our loop. So that's how we break
out of our infinite loop. If we don't break out
of our infinite loop, we yield that item. So yield is similar
to return and we'll talk about the difference between yield and return in
just a few minutes. So let's go ahead
and define a class that's iterable and
returns an iterator, and we're going to use
a class called decades. All objects, as you know
from your background in object-oriented Python
implements an __init method, that's its constructor. So in this particular case, we're passing in a
parameter called years. We're going to set a variable
called years to that value, and we're also going
to instantiate another variable called index and we're going to
set that to zero. Our __ iter method will
actually just return our self because we already
implement an __next method, so that's an iterator. So __iter can simply
return itself. So an object can be both an
iterator and an iterable. The next method that we define is __next so that it
can be an iterable. In this particular case, we're going to run through
this list of years. What we're going to do
is walk through each of those by looking at
our index value. If our index value, which starts out at
zero is greater than the length of that list of years, then we're going to raise
our StopIteration error. Otherwise, we're going to take our return value and set it to the index value of years and we're going to divide that by 10 and
multiply it by 10. So a floor divide on a year, multiply it by 10 will
yield it's decade. You can demonstrate
that to yourself. Then we're going to
increment our value of index by one and return
that return value. So here, we are in our notebook and we can go ahead
and define that class. What we can do is we
can instantiate that as decades and call iter on it to give
ourselves an iterator. Now in this case, what
we're going to do is we're going to just
throw that exception, we're going to throw that
StopIteration exception and we're going to catch
it somewhere else. We might, for example, decide we're going to
catch that inside. But in this case, we're
going to propagate that out to the color. So when we call next
decades_iterator, the first time we get 1970, which is the decade for 1971. When we call it again,
we'll get 1980, which is the decade for 1982. When we call it again, we'll get 2010 for the year 2019. Can you guess what's going to happen when we call it again? That's right, we get a
StopIteration exception raised.