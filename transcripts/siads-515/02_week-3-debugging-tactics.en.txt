In terms of the tactics that
we're going to be using, there are about five of them
that I'd like to cover. The first one is print debugging. We'll spend a fair bit of time talking about that because that's probably what you're going to
be doing most of the time. Another aspect of debugging tactics is
interactive debugging. So we're going to
be using something called pixie debugger, which is an advanced
graphical debugger of now available in Jupyter notebooks. We can also do control
flow analysis, which we're not going
to spend too much time on if at all. Unit testing, I
talked a little bit about which is where
you're going to test the basic functionality of every function that
you write or use. Finally, profiling, which we are going to spend
some time doing today. One of the things that
I want to let you do as data scientists is the notion that sometimes
the bug is in the data. So sometimes the problem
does not lie in the code. The code works perfectly fine, but there's a problem
with the data. Sometimes it's also easier and faster to fix the data
than to fix the code. In other words, don't write
code if it's going to take a long time and it's
not going to be reusable. I've seen a lot of people spend a lot of time writing
code to take care of edge cases with data
when in fact it would have been easier
to fix the data. Now admittedly, it's
more fun to write code than it is to get in there with the simple editor
and fix the data. But you have to
think very carefully about the trade-offs in terms of time and money when we're trying to do things like
debugging efficiently. Remember, the course is about
efficient data processing. So we're also talking
about efficient debugging. The first thing I
wanted to talk about is something called
a Python traceback. This is also called
a stack trace, or a stack traceback
or a backtrace. They're all the same things. We just use slightly
different terminology. I think the most
common one that you'll encounter is Python traceback. A Python traceback occurs when your program raises an
exception that's not caught. We'll talk about how to
catch those in a minute. So here's an example
of a traceback. This is a very simple example. So here we have
three lines of code. One, the first line there, where we assign the
quick brown fox as a list of four strings
to the variable tokens. Then we use a for-loop for token in tokens and
we print out token. When we run this code, we find that there's
a name error. This is an example of a very simple stack trace where we're told at the top that
there's a name error. You see that in red. Then we have some Python code. The first little bit there
in the angle bracket IPython input isn't
particularly meaningful. So you don't need
to pay attention to that number in the
angle brackets. In module, means that
it's a baseline module. The next three lines correspond exactly to the lines of code
that were written. So you see that line
1 is tokens equals, line 2 is the for-loop, line 3 is print tokn. That arrow here that
points to three, signifies to us where
the error occurred. So print tokn is problematic, and it repeats the error that wasn't caught at the bottom. So name error tokn
is not defined. Now this is a very
simple and very intentional error where I mistyped the variable name
T-O-K-E-N as T-O-K-N. It's saying that name tokn
that variable is not defined, so I can't print it.