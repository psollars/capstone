So let's talk about decorators. In that example from above, where we
have one function, memoized Fibonacci returning another function, so the
internal function wasn't memoized as well. It was just Fibonacci. That is a more specific form of
a general approach called decorators. A decorator is a function that
takes another function and extends its behavior without
explicitly modifying it. The simplest decorator then is the no
decorator, which does nothing. So here's an example of a null decorator. Where given a function,
it will just return that function. So if we take a function like hello,
that returns hello and decorate that with the null decorator,
we find out that that prints hello. So the important thing here is that
functions are first class objects within Python and can be passed
as parameters to other functions. If we look at a slightly more
complicated decorator this one called emphasize that takes a function,
and we're going to define a wrapper
around that original function. So that original function will be called
here, and we'll get a return value. So remember we're going to pass
in to emphasize some function, probably one the prints
something like hello. We're going to get that return value, and
then we're going to modify that return value by adding to it the string
"<em>" and the string '</em>". So this is sort of old-school HTML
where we're using an emphasis tag around some original text. And we're going to modify and we're going to return that
modified return value. This emphasize function, however,
is a wrapper around another function. So we're going to return that entire
wrapper to allow us to parameterize out what the original return value is. Let's take a look at that
in the notebook itself. So here's the code that we just
looked at in the slide, and here's the way that we're
going to set up that decorator. And when we call that decorator, we're
going to get our emphasis tags "<em>" and "</em>" around hello, and you can
study that to figure out how it works. Okay, let's look at
a way to simplify that. If we take our original function
the emphasize wrapper here, which is the same as what we saw before. We can add that as a decorator
automatically to Hello by using at emphasize or at the name of
the decorator right before the function. Let's take a look and
see how that works inside the notebook. So here we have emphasize,
defined as we did before. And then if we use this
specific at emphasize form right before our function of hello and
call hello, we automatically decorate hello
with our emphasize decorator. So at, and the name of a function, is a simple way of adding
decoration to a function. Now, let's push on that just a little
bit more by looking at a function that takes a parameter. Let's say I define a multilingual hello
function whose default language is 'en', so lang equals 'en'. Inside that function, I'm going to set
up a dictionary called lookup that maps the two character shortcode for language to the implementation
of hello in that language. So we have 'en' Hello and French Bonjour. And our return value from that function is
something going to be the lookup value for that language that's specified,. And we can call that as multilingual
Hello for 'en', and for 'fr'. Let's take a look at that in the notebook. So here we have our function. And we'll call that with 'en' and we will similarly call that with 'fr'. And let's say that we now
want to decorate that function with our emphasize decorator. If we did emphasize multilingual hello, if we decorated that with our at emphasis
at with our at emphasize decorator, we could call it as multilingual_hello or
multilingual_hello "fr". Let's see what happens there. So we've used are a form of decorator. We call multilingual hello, that works. But when we call it with an FR parameter, we're told that the wrapper takes 0
positional arguments but one was given. What just happened? Our wrapper isn't set up
to take any parameters, but our underlying function
expects one optional one. We can accommodate our decorator,
we can change our decorator to accommodate the optional parameters by using *args and
**kwargs, or keyword arcs. That's a way to pass in
additional parameters. So our parameterize decorator could
look like this, where our emphasized, we're calling it emphasize
underscore args. Now, we'll take our original function,
we'll define a wrapper that takes zero or more positional arguments plus zero or
more keyword arguments. Our original return value then will
be that function that we passed in called with our arguments and
keyword arguments. And then we're going to take that
modify it that return value, and modify it as we did before. So let's take a look at that
inside of our notebook. So here we have our
emphasize args wrapper. We're going to decorate that
multilingual hello with emphasize args, and then we call that with FR we
get back what we would expect. So let's go back to memoization, and this time just another super
quick regression, functools. Functools is a collection of function
tools that does a lot of common tasks that we'll need to do when we're
trying to write efficient Python code. And I would recommend that you take
a look at the documentation from the URL that's on the screen. Functools, according to the web page, offers higher order functions and
operations on callable objects. The one particular piece of functionality
from functools that we're going to use is something called lru_cache,
and that's a decorator. So we're not going to spend time
looking at the rest of functools, we're going to be looking at lru cache. So the whole digression about,
generally about decorators, was setting us up to use this particular caching
mechanism around our Fibonacci generator. So to use the functools lru wrapper, what
we're going to do is import functools, and then decorate our Fibonacci
generator with functools lru_cache. lru_cache stands for
least recently used cache, and it's a way to maintain our
cache size at a set maximum. So we don't want to store an infinite
number of values that would become inefficient for
memory consumption reasons. So we're going to have to prune
our cache once in a while, and lru is one mechanism to do that. So I've done it one way here,
import functools. I could equivalently say from
functools import lru_cache. Thereby bringing lru_cache
into our namespace and decorating are Fibonacci
sequence with lru_cache. So if we put that all together
we can go ahead and tie it. Use time it to calculate the times for
different Fibonacci sequences. Let's go ahead and take a look and
see how that looks. Let's import lru_cache, and
let's now time our Fibonacci sequence for 10, which has now been decorated
with the least recently used cache. We find out it takes 74 nanoseconds. If we do the same thing for
Fibonacci sequence of 20, we find out that it takes exactly
the same amount of time plus or minus if we do it for 30. And if we do it for 40 we are roughly at
the same amount of time for each one. So what we've done there is
taken our Fibonacci sequence, we've used a decorator to
allow us to decorate all of the calls to Fibonacci to make
them the memoized version. Thereby saving on the order
of somewhere between one and three orders of magnitude time. So that's it for this week's
exploration of efficiency in Python.