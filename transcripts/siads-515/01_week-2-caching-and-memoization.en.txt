The next topics we're going to
cover are memoization and caching. But first I'm going to introduce
you to the Fibonacci sequence or series or numbers. So the Fibonacci numbers consists of, the first few Fibonacci numbers consists
of the ones you see on your screen. 0, 1, 1, 2, 3, 5, 8, so on. And if you study that pattern long enough, you'll see that with the exception
of the first two numbers, each of those numbers is the sum
of the previous two numbers. So you get 0 and 1 for free, then the sum
of 0 + 1 is 1, the sum of 1 and 1 is 2, the sum of 1 and 2 is 3, 2 and 3 is 5,
3 and 5 is 8, 5 and 8 is 13 and so on. So this sets us up for talking about why
we want to use memoization and caching. Let's time our Fibonacci function
using our timeit magic command. So here's the definition
of my Fibonacci sequence. So this is just operationalizing
what we talked about earlier. So if n equals 0, we're just
going to return 0, if n equals 1, we're going to return 1. Otherwise, we're going to
return the Fibonacci value of n -1 plus the Fibonacci of n -2. So those of you who are strong on your
computer science will recognize this as an example of recursion. So if we do a timeit of Fibonacci
on some number like 12. So let's go ahead and
run that to define our function, and then we can go ahead and time it. So timing Fibonacci of 12
numbers takes a few seconds and we find out that it
takes 68.6 microseconds + or- 6.52 if we start pumping
that number up a little bit. So now you see with
a Fibonacci of 22 it's taken substantially longer at
8.39 milliseconds per loop, which is a substantial jump for
what we saw a minute ago. Let's talk a little bit about caching
which will help us understand why we want to memorize that. So remember as we went from a Fibonacci
of 12 to a Fibonacci of 22, we saw a tremendous jump
in how long that took. So caching you may have heard of,
it's typically done with web browsers and web pages. Let's take a closer look at a form
of cache and called memoization. So here's memoization as an example. What we're going to do is we're
going to define a memoized function. We're going to create a dictionary
called Cache, and we're going to define inside of that a memoized function that
takes as an argument another function. If the arguments for
that function are already in the cache, we're going to simply return the cache
value of the former function call. Otherwise, we're going to
save the result as of that function called with those arguments,
cache it and return the result. And then finally we're going to
return that memorized function. So what we're doing here is we're saying,
for a given input, if we have already calculated the output,
just return the pre-calculated value. If we've never seen that given
input before, then go ahead and run the calculations and then save
the output right before you return it. So you see what we've done there? We said if we already know the answer,
given some arguments, just return it. Otherwise calculate it,
save it, and then return it. So let's go ahead and
do that memorized function of Fibonacci. So here what we can do is create
a new function called memoized Fibonacci that is the value
of memoizing Fibonacci. So here our memoized Fibonacci is
that wrapped function of Fibonacci with memoize where we're
maintaining a cache outside of it. If we time the memoized Fibonacci of 32, so we're calculating the first
32 Fibonacci sequences, we're told something a little
bit different with timeit. That the slowest run took 5.33
times longer than the fastest. That could mean that an intermediate
result is being cached. So timeit is smart enough to recognize
that there's a change in terms of how fast that function runs depending
on how many times it's been run. If we call Fibonacci of 32
we get the same result. So there's not a substantial difference. If we look at Fibonacci of
10 in the memoized version, we find out that it's even faster. So we're down to nanosecond range. But note that the memorized version
doesn't call the memoized version when it recurses, right? So out here we've memorized
the outer layer of the Fibonacci function but
not the inner recursion calls. In other words, we can provide
an elegant solution to this using Python decorators by further
memorizing that function.