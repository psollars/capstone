Welcome back, this week in the course
we're going to be talking about two kinds of different things,
debugging and data structures. We're going to start with debugging and
then we'll move on and talk about some data structures. We are going to be using some of
the simple data structures that you should be comfortable with
in our debugging stuff, and then we're going to move on and
do some more advanced data structures. So our overview for today, as I mentioned,
is these two sections, debugging and data structures. For debugging we're going to talk really
quickly about the history of debugging. We're going to cover some
debugging tactics, then we'll delve into some examples that include both
print debugging and interactive debugging. And I'll be introducing you to something
that's kind of new for jupyter notebooks. After we're done our segment on debugging,
we're going to move on and do a segment on data structures. And we're going to go over,
once again, some of the basics. So we'll go over lists, tuples, some of you might say that as tuples,
sets, and dictionaries. We will also be talking about collections, which are advanced data structures that
are really helpful for data science. Will be looking at things that
are called counters, defaultdict and namedtuples or namedtuples. So debugging has a definition, and if we
pull this from Wikipedia, we read that debugging is the process of finding and
resolving defects or problems within a computer program that prevent correct
operation of computer software or system. So that's a definition that
kind of talks very dryly and technically about what debugging is. I think we can do a little bit better. So let's think about the history of
debugging and where this came from. So the initial bug was literally a bug and
it was discovered by now Admiral Grace Hopper who was
responsible for a computer system. And in those days,
they used relatively large equipments. So these are things that
took up rooms in a building. And they used some pretty
heavy-duty hardware like relays. There was a situation where something
wasn't working properly and what it turned out to be was that a moth had landed
on a relay and shorted out the relay. So literally there was
a bug in the system. And that's where we got on
to the concept of a bug. So now we obviously don't have
insects landing on our systems and making them not work, but we still have this concept of something
has caused a problem with the system. The next major step in the history
of debugging was gill's diagnosis of mistakes. And here's a brief excerpt
that you can read on your own. There's the link at the bottom of
the slide on the diagnosis of mistakes in programs on the ad side, which was
one of the early computers.And you'll see that this was done in the 1950s. So very early work on
debugging mistakes and programming, how these might be
resolved and how to describe them.So this was really early stuff that
was happening in the 1950s. When we talk about debugging,
there are basically three steps that we would formerly follow if we
were doing a formal debugging session. So the first thing we want to do is
attempt to reproduce the problem. If we can't reproduce it, it becomes
incredibly difficult to debug the problem. The next step after we've
successfully reproduce the problem is to simplify the affected code. So if we have very complex code we
might want to change that out to make it simpler flow control,
simpler to read, simpler to understand. Even in doing so, that could solve the
problem because in simplifying the code you could detect the problem. They also could be a problem
in the input data. And we'll talk about fixing
the input data as well. Another thing that we can do in
debugging is to create a test case. So what we're going to do there is we're
going to create some data, and we're going to try to feed that into the system
and see if we can get predictable results. There's another type of development
that we're not going to cover in this particular course
called test-driven development, which is all about
writing test cases first. So we would actually go down and
create something called unit tests. And those unit tests would all have to
successfully run before we go on and write the next bit of code. So we're not going to be doing TDD,
test-driven development, but you should know that it exists