So now I'm going to show
you just a bit of a demo. Now I'm not going to
do this demo here, I'm going to make
a separate screen recording because
I like to give you screen recordings for things where I want
you to follow along. But basically, if you recall in a previous assignment,
previous lecture, the thing we did was we made a database and we were getting rid of
vertical replication. Vertical replication
keeps coming back, right? So here we got some
vertical replication, two things like make and
model of whatever it is, we got some vertical replication. So we're going to end up with a little table that is
our lookup table here. That is this second thing
that says B is 1 and then we're going to end up with numbers like foreign key into
this table y_id, and we're going to
put these in, right? So I could give you
as an assignment take this data, make two tables, send one as a foreign key into
the other and put the second column in and just
put the distinct values. Sound familiar? Just
put the distinct values of that second column into here. That's what I want you to do and I want you
to do it by hand. So what we're going to do in this particular thing is
we're going to automate it. And we're going to make it
so that you could really take any and it doesn't
just take two tables. You could extend this to
me more than one table, I mean more than two tables. But it's going to
auto-generate these things and we're going to use
things like DISTINCT. We're going to use
things like sub-selects, and I'll talk about it. When I talk about
I'll go like see how we're using the sub-select. Yes, if this was an
online application it would matter, but it
doesn't. We're using kind of this batch job that's taking this CSV file and turning it into a set
of normalized tables. And so the key thing is this might not be using the best techniques
for online applications. But this the best technique for the convenience of getting a nicely normalized database out of a non-normalized CSV file. So I'll go over
this and show it to you in some detail
and it will use most of the ideas that we talked about in this set of lectures. So in summary, a lot of
what we talked about in this set of lectures is
the SELECT statement. And SELECT is often the last thing I talk about because CREATE, UPDATE, and DELETE are like
they're the big ones. And SELECT, oh yeah,
that's how you check to make sure
those other ones work. But it turns out,
as I said before, the SELECT is where a lot of this relational power matters. So the SELECT like
narrows your view which increases performance then this whole DISTINCT
thing happens. And so if you go and you look at the documentation on Postgres, you will see that literally
we have only talked about almost half of what SELECT does and there's so
much more that it does. And again, the SELECT, the looking at this stuff in the database after you've done all
this normalization and all this optimization, how you ask to look at it is super critical
and super amazing. But we've done a pretty good
job at this point covering a lot of the different things that SELECT is capable of doing. So up next in the next set of lectures we're going to talk
more about text data. We'll talk a little
bit about text data in that demo that I'm
going to show you in a bit but we'll talk a lot more about text data in
SQL coming up next.