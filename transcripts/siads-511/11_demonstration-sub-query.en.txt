Hello and welcome to
another SQL walkthrough. In this walkthrough,
we are going to talk about sub-queries. And so sub-queries are a powerful and
useful technique. People don't like using them in
high-performance situations, like for online systems, but we're going to
use them a lot for data manipulation, especially the kinds of things
that we're just going to do once. Or it's a way to manipulate data that
we're not going to do 1,000 times a second. So let's take a quick look at some data. The idea of a sub-query is it takes the results of one query and
feeds it into another query. So if we just take a look here. So we get SELECT star. This is pulling out a
one row of a record. But if I switch this to be, SELECT content FROM comment
WHERE account_id=1, well that is going to find one
of the comments for Ed, right? So if you recall earlier when
we were hand-constructing some of our many-to-many relationships. We were remembering. So let's actually make this
be a SELECT star SELECT star FROM comment
WHERE account_id=1, right? And so account_id,
we're knowing what these things were, what these post_ids were. We're figuring all these things out
by hand. But we can actually look at this. So we can say, wait a sec,
we actually know, we have a way of looking up this number 1. And we can look it up
with a WHERE clause here. And so what we're going to say is
I'm going to say SELECT id FROM account WHERE email equals ed@unich.edu. So here we go. This is a way you get at that number. Wouldn't it be nice if we could
say we could run this one here and get this number here instead. And then we could actually look up
content from comment where email equals ed@unich.edu. And that's kind
of what the simplest of sub-selects are. So what I'm going to do is I'm going to
go right here and I'm putting some parentheses, and I'm going to take this
SELECT statement and put it in there. So now I have SELECT content FROM
comment WHERE account_id equals, and then this SELECT statement. This is why they call them sub-queries or
sub-selects because what it does is Postgres runs this SELECT, gets this
number, and then runs the outer SELECT. This is both the reason that people love
them and the reason that people hate them is that it requires in effect
two separate operations which the outer operation is in a sense paused
until the inner operation finishes. What we're doing here is almost
instantaneous for both of them, but if you're doing this for a long time
on things that run over and over and over again, it can be inefficient. But basically it works
exactly as you would expect. Now and so the way you work is you work
until you get like your query the way you want it that gives you this number, and
then you have a query that uses the number, like this SELECT content query. And then you say, oh, I can combine those
two things, and so away that I go, right? So that's what the simplest
of sub-queries is. And so that's a very, very simple
sub-query and it's very counter-intuitive. Now, there is another
version of the sub-query, and let's go back to a previous example
where we are using the HAVING clause. Remember the HAVING clause happens
after the GROUP BY process. So we have this GROUP BY and then we have in effect the results
that come back from that so we can get that GROUP BY to finish, and
then we have this HAVING clause, and then we're going to have an ORDER BY. Well, what if you didn't
have a HAVING clause? You could use an outer and
an inner WHERE clause. So you take. So what we do is this, right? SELECT
So let me do this a little differently. Let me change where this line breaks, and then we put this parentheses out here,
make this more than one line so you can see a little better. Okay. So this is a sub-query right here. And this is a query you can run. You can actually run this query and
you can see what's going to happen. Oops, I forgot a semicolon. And you see that it's a series of rows. So this is a query that doesn't,
like the previous one we just made a single number, this one
creates a previous set of rows. So what I can do this,
is now I can put this in the FROM clause. So this the FROM clause to
this outer query ct abbrev. And then away I go, right? And so I give this AS zap. This AS zap is a way to give this
inner temporary table in a sense. This is like it's going to make a table,
because this whole parentheses right here is, that's like a table that
I just am making temporarily. I'm running this query,
I'm running this query right here. And then I am creating a table
that we'll temporarily name zap. And then I'm going to SELECT from that and I'm going to apply a WHERE clause to it,
right? Actually this one would be better
done if I made that be a false. So this shows you a technique that I
use a lot and that is I use a text editor to build up my queries and then I pop them over and
then I copy them and I paste them in. So, if I don't like it, I can change it. So, there we go, we get a
little better count there, right? So, there is 26, 35. We are going to try to make a WHERE
clause, but this outer bit, that is going to be the table, quote, unquote, from
which this outer clause is going to run. So without further ado, let's do that. So we're going to see and you all
as you build these, you'll notice that the output of this query is two columns,
and I am treating those. And I can give these things different
names because this ct is just the first column of the inner query. And abbrev is just the second
column of the inner query. And so but there has to be the same number. If I don't
put the same number here, it'll be unhappy. But then what I can do is I can treat
this output as a table itself, right? And so that's what's going on. And so if I run this whole thing, you're going to see this
with a WHERE clause, right? And the WHERE clause is this
outer number, this ct. So this became a table, and
that became a WHERE clause. I could even add to this an ORDER BY. But then that ORDER BY ct DESC. So that's going to order by this ct,
which is this virtual column here. So that's going to order
by them in descending, so the largest one is going to be first. And so, the sub-query is one of those
things that it's really essential. And, again, it's an optimization boundary
where we can't make this query go faster. This outer query must completely wait until the inner query
is completely finished. And then, it sort of,
if this query is big enough, it kind of has to write
it all out to disk. And then it has read that query back in. Now, nothing here is large enough
that it matters. And it's all instantaneous. But this is why database
tuners, especially for online systems, do not like sub-queries. But for us, in more of
a data mining context, sometimes sub-queries are essential. And we are typing commands that
might run for half a second, but we're only going to type them once and
so we're not running an online system. So sub-queries are super powerful and
a lot of potential, but we avoid them quite
a bit in online systems. Cheers.