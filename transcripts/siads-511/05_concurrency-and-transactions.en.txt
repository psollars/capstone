So now we're going to
talk about concurrency. Concurrency makes the most
sense in an online system. And like I said, data mining doesn't
always work with an online system, sometimes data mining is working
on an online system, but concurrency is an important concept and
I just sort of want to bring you up to sort of basic understanding
concerning concurrency. If we're teaching sort
of an online gaming, how to use databases on
online gaming or something, this would be an essential part of it. We'd spend a lot more time with it. So databases in general are designed
to be multi-user, right? You got a database back here and you got a
thousand simultaneous logged-in users and they're adding 1 or subtracting 1 or
updating their bank balance. And it's kind of like database sees this
flow of continuous transactions coming in. And the key the database
has to solve is atomically. So in this case, we've got,
simultaneously, we're going to receive three update statements that are going to
set count = count plus 1 for our row number 42. And now all we need to know, we don't
necessarily know which one of these is going to go first, but we know that after
all three are done, it's got to be 103. And the place that it might not be 103
is what if what it did was the first one retrieved the old value,
the second one retrieved the old value, and the third one retrieved the old value,
and they would all have 100. They would all add 1 to it and
then will store the new value and would all store 101. So you had three attempts to
add 1 to it, but the number went from 100
to 101 instead of 103. So that's the problem. The problem is we don't know which
one actually has to go first. But at the end, all three have to happen,
which means that the database has to enforce a rule, here comes
an update, if there is two updates, they got to go in some order but
they can't go at the same time. That's the concurrency bit. They can't be at the same time and
that's the atomic bit. So the read and the write of the value
count has got to happen atomically before the read and the write of the value
count for the next transaction so that's got to be atomic, okay? So the way this really works is there
is a locking mechanism inside these databases and the better the database,
the better the locking mechanism. because if you're doing a lot of
locking in a database, then actually, the lock effort is often greater than the
cost of just reading and writing the data. And so when Postgres says,
we're really awesome, or Oracle says, we're really awesome,
the granularity of the locks and the performance of the locks, and
the amount of memory that it takes to do locking as your database
size grows, that's like a competitive strategy, competitive
advantage to be good at locking. Because this atomicity, the atomness,
the ability to do things atomically, is such an essential
feature of a relational database. So the pattern is really simple. What you basically do is
if you're going to update something, you've got to first lock it, then you can
read it, then you can add 1 to it, then you can write the new value,
and then you unlock it. And if two things go to the lock at
the same time, one gets the lock and the other one has to wait. And then the one that gets
the lock gets to completely work and this one is still waiting and
then when this one unlocks it, then this one gets to come in, but
then they're going to see 102, right? So it's lock, read 100, add 1, store 101, unlock, read 101, right? So that's how you guarantee that if
there are three coming at the same time, it goes from a 100 to 103
rather than 100 to 101. And so each of the SQL statements
that we send are atomic and it's not just update statements. Insert statements are also atomic and when
we use a serial-type column like id in all these tables that we're building, we're
basically saying I want a unique number. You can't have three simultaneous
inserts happening say, you know what, you're all key number 1 and
the next insert's going to be 4. We do know that we got three records. No, one of these has to be 1 and
the next one has to be 2, and the next one has to be 3. We don't know which one gets which,
so even when they're insert statements, they somehow have to line up
behind each other at least in the id and unique key generation,
the primary key generation. They've got to line up behind each other so
that they get a unique thing, right? But you can't say who got there first
because they arrived at the same time, but the database will force an ordering
on them and the next one will be 4. These three will be 1, 2, 3,
but in some random order. So because each statement, and
when I say a statement, what I really mean is a bunch of stuff
that ends in a semicolon, right? So this is like an INSERT blah,
blah, blah, blah, blah, semicolon. So there are things that sort of extend
one statement to do two things in one statement, right? So more than one thing in one statement
for efficiency and concurrency. So one of the things you can do is you
can do an INSERT and then add this little kind of like extra little things that hey,
you inserted all those things into the thing including the primary key, which is the id,
that you generated, and give it back to me. And then this becomes
one atomic statement and your code gets back the numbers,
including the automatically assigned id. And the same thing is here. So if you say I want to add 1 to this,
set howmuch equals howmuch plus 1 where post_id equals 1 and
account_id equals 1. What value was it afterwards? How many were there? Like you might be
clicking a button like this that makes something go up, and
then what's the new number? What if two people in two
screens are clicking that same button? It shouldn't be 80. It should be 81. So
you can basically click this button and it will send add 1 to it and say what's the resulting number and
the answer will be oh, 81 because other people were clicking at the exact same time. And so that's what this is
saying is add 1 to it and then afterwards give me that record
back, the updated record, right? Cool. So that's another taking
advantage of this concurrency and the atomic nature of each SQL statement by
adding stuff to the same SQL statement. You can't just keep doing this forever. This RETURNING is a feature
that we use and we use a lot. So the next thing that you do is
sometimes you make a constraint and with the intention that you're going
to bump into the constraint and then tell it what to do when it
bumps into the constraint. You can almost think of this as like
a try and except in Python where you say like try this. If it works, just great.
If it doesn't, do this other thing. So if we inserted a record, this record here,
and then we tried to do the insert again, it would actually fail, right? And so
sometimes the record exists because because a unique constraint on post_id and
account_id because the insert that's already, there that combination
of 1,1 is already in the database. Because of this insert. Now this
one here is going to fail. And so it's just going to blow up but it turns out that what you can do is you
can say I would like to insert this stuff. So a lot of my updates turn into
inserts and then ON CONFLICT. And so what this is saying is if
this insert would fail because of the unique key constraint of post_id and
account_id, don't blow up but instead, this is like this
is like the try/except, instead, add 1 to the thing that's
there. Add 1 to that howmuch value, okay? Set howmuch equals
fav.howmuch plus 1. So that's like try and except. This update
doesn't trigger unless this is true. And so this always works and it works whether
there's a record in there or not. It works where those record in there or
not, and it does a third thing. So it's got an if statement in here.
If this insert is not going to work well, then do this instead.
And oh, by the way, return the new data whether it
was an insert or an update and that includes the new value like
the 85 or 90 or whatever. It is after you click this, right? Now, if there's zero here then it's going to
insert it and you're going to get 1 back. If there's 79, you're going to insert it. you're ging to update it,
its going to be 80. Of if a bunch of people are updating at
the same time and you might update and get 85. And it all works and
it's all it's all atomic, right? It's all atomic and
this is one transaction, one SQL statement, one semicolon.
And it's a beautiful thing. And so if you look at my code and you find
I'm doing I'm doing a lot of inserts where you think I need
to be doing updates. Because it's really it's insert only
happens once and then the primary key the the unique constraint clicks and
then it just turns into an update, but it's easier than me putting
an if statement and making two actual SQL queries because
that's costly and that's a waste of time. So I'm not going to go into great detail. I might do a little visual demo of this. This is what we do when we're actually
explicitly doing transactions. I haven't done this much mostly because
the applications I build are online but not banking but the one time I did it I
built a little tiny multi-user game to match people up to play
Rock Paper Scissors and then play the Rock Paper Scissors. And the problem I had was when you're
starting to play Rock Paper Scissors and you pick your Rock Paper Scissors and
you want to play, we have to decide if someone already is halfway into a game
and you play them or you start a new game. And so you kind of have to go and
you have to check to see if someone's ready to play a game and if they
are ready to play a game, then you lock them. And then you play the game and then update
them and then one of you wins, right? So there's things where
you just have to grab the data. So this is real transactions, right? You're really going to do it. And in
particular, it has to do with time passing. And so I want to say SELECT howmuch
FROM here WHERE this AND this and then this FOR UPDATE. This is this for, oops. This FOR UPDATE, that basically says lock it. It doesn't lock for people who are just reading it, because they
might read it before you change it, they might read it after change it, and
because of the asynchrony they kind of don't know. But if there's anyone
else that's also locking it for update, if you get here first,
then this one will actually wait. So if you select it and no one's done it
and you can get both the data and the lock so you get the howmuch value and
you have locked it. And if you wait you are now just there's
a little wall around that row that you put there so I say FOR UPDATE you put a wall
around that row the second one comes and they hit the wall and they simply wait. Now
they only wait, you know, 30 seconds or something because these locks are not
supposed to last a super long time. They're supposed to be like, you know, just like a millionth of a second and
be done with but you can, if you're doing it by hand, be
mean and hold a lock for a long time. So you this is where you might do this
with two windows. You do a SELECT, hold a lock, and then in the other window
you try to select and hold a lock and it just sits. It doesn't even say could not find lock. It just stops and sits. And
then what you do is do your stuff and there are one of two ways to end
a transaction. One is ROLLBACK. And ROLLBACK basically says I want
to whatever I did since I said BEGIN, discard it. Unlock it, unlock
everything, and discard it. COMMIT says take what I have done and
commit it to the database. So in a sense when I do a rollback,
this update doesn't even by the time you get down to here, this update was actually discarded.
In a sense what you're doing is you're kind of working on
a copy of the row in here and then the rollback says throw away
the copy and let go of the lock. Here you're working on a copy of
the row, but it's blocked for others so they can't use it. Here you're saying update the
real row and let go of the lock, okay? You can read up on this. It's pretty cool. And there's are some I've given you
only the very simplest bits of it. As I said earlier, the performance and
lock granularity is a feature for a database that says I'm an awesome
database because of how I do locks. And so the lock implementation and how we
serialize simultaneous access to various parts of our database is a core competency of
database systems. So I didn't cover everything. There's some more things like, you know,
sometimes you're you're getting a least less strong lock like you're going to
update this record including maybe change its key or a NO KEY UPDATE means I'm going
to update this record and I'm not going to I'm going to update something in it,
but I'm not going to change its key. You can tell what to do when you're
waiting for a lock. You can say, you know what, I don't even want to wait.
Just select it for update and if I don't get it, tell
me I didn't get it and let me do something about it. And SKIP LOCKED is when you are doing a select
from multiple rows, which you can do, for update and there might be four rows that
would meet your WHERE clause but only three are available because the one of
them is locked, you'll get three rows back. So I would like to select something
for update. SKIP LOCKED means just give me the rows
that are not currently locked and give them all to me if there
are none that are locked. And so those are all really cool features. And once you kind of get
a little more skill in it, these will make a lot more sense to you. So up next we're going to talk about
stored procedures and stored procedures are another way when you have multiple
things that you kind of want to do. You kind of store the code
in the database server and it runs in the database server
versus you writing a bunch of Python say outside the database server and
running query after query after query. Some of these multi-step activities
can be moved into a stored procedure.