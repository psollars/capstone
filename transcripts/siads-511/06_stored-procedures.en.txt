So now we're going to talk about stored
procedures. Stored procedures is another one of those topics that you can start
a conversation in a coffee shop about stored procedures and
people will often have strong opinions. And I'll share my strong opinion with
the understanding that it's just an opinion. I tend to avoid stored
procedures at all costs. And the reason that I don't like
stored procedures is I tend to move from one database to another. Now,
you know, if you're working for a company and that company is
a Postgres company, then, you know, they're not going to be
nearly as opposed to stored procedures. But if you're moving from
Oracle to Postgres to MySQL to SQLite and and you
start using stored procedures too much, they're generally not portable at all. Even what's possible to be done in stored
procedures has slight variations from one database to another. But if you're
a company that is a Postgres company and you're building an online system and you
have some query that if you did it all kind of run a query, run a query, read
the results, run seven more queries, then do this other thing, and you had to do
that for like your main screen, that would be so dog slow. It would be so
horribly slow that you'd be like, can we please make that main screen
be a stored procedure and someone like me be like would be like oh, man,
I really don't like stored procedures, but our company's going to
go out of business if we don't take these nine SQL statements
with some if statements in the middle and just turn them into a stored procedure. So from a performance thing,
they're pretty awesome because they take multi-step processes that are full
round trips between an application like pgsql and your database and then
do them all in one database transaction. So the fewer SQL
trans statements and fewer round trips between your
application and the SQL database. So they're both wonderful and scary. And so I just
I don't say I never use them. I just tend to use them kind of in
I like to isolate them and have a real strong reason why I'm going to do it,
like I said. A strong reason to use a stored procedure is to solve a major performance
problem, because they're harder to test and they're not portable and, you know, maybe
there's some rule that you can enforce on a CREATE statement like a constraint or
a unique key. The one time I wanted to do this, well, the Postgres did it, was a key
where this instead of me saying this field has to not be null and
this field has to not be null. I wanted to say one of these two fields
must not be null but it's okay for either field to be null as long as
the other field is not null. And there's no way to express
that in a CREATE statement. And the only way to do that
is to do a stored procedure. The way I ultimately did it was
I didn't use a stored procedure, I just made sure I never put records in
that violated my rule of two nulls, basically. I didn't allow two nulls. Two
columns, two nulls, I wasn't allowed to do. So if that's kind of a rule
that must be enforced and as we as a develop software developer,
I would much rather have been able to enforce that rule in case I as a software
developer made a mistake, And when I am told by my database that I
write some SQL and I've violated a rule, I'm not like mad at the database. Because it was my rule that I
put in there to catch myself and keep myself from making mistakes. We do that a lot when you're writing
trying to write really reliable software. You make rules that when
you break you get stopped. So you at least find when
you're making mistakes. If you well whatever, we'll just let it go, well, then you don't find your mistakes. So that's the whole idea
of a stored procedure. That's like double-checking something
to say don't be doing this. So I'm going to go back and talk about
one stored procedure and it has to do with the updated_at in the updated_at
field here in our favorites table. So the updated_at from sort of a semantic
perspective is going to capture the moment that this was last modified. So created_at is when it is first
inserted, and updated_at. And if you recall, the DEFAULT NOW
says at moment of insert pick this current moment in time and
store that in the database. And so the problem is that if I want to do
this and I have this updated_at, then every time I'm going to do
an update statement I can't just do the update of the thing I want to update. I got to say updated_at equals NOW. Now I don't know if you consider that
to be like a really terrible task, but other databases actually do this for
you automatically. You just have a little different thing
that you say right there and you like make just update this every time. Come on, it's
this thing I want, right? But you can't do that. You can't indicate on a CREATE statement
that you want updated_at to be automatically changed upon update. The right way is to use stored procedure,
and it's a super simple stored procedure. And so it's the one stored procedure I'm going to show you. I don't expect you to write
a lot of stored procedures, but I just do want you
know what they look like. So the way we're doing this is we're
going to create a trigger function. What a trigger function is like
when something happens, do this. So we're going to make a function.
We're going to give that function a name. And it's going to be called
trigger_underscore_set_timestamp. This could be gorp for all we care,
that just happens to be a mnemonic name trigger_set_timestamp. This function we're making is to
be used as a trigger in that there are other ways to do it. You can make you can make a trigger. You can make a statement. There are various other
things that you can do. You can have a function,
a trigger, a statement. But this is a trigger, which is a bit of
code that's going to run either before or after some SQL statement's going to run. So what we're going to do is the BEGIN and END is the actual code of our stored
procedure and all we're just saying is whenever we're going to do
whenever something happens to this record, that's what the NEW is, we're going to set
updated_at to be NOW, and we're done. So we're sort of sort of manipulate. There's a record about to be
put into the database and right before we put it in the database we're going to sneak the current time into
updated_at so when it goes into the database it's going to be changed.
And then this is all just syntax double dollar sign and
plpgsql, that's the weird language. Postgres supports more than one language. I don't like stored procedures. But if I do stored procedures, I prefer to use the built-in language.
You can use like TCK TK and pearl. None of those things seem appealing
to me. plpgsql doesn't appeal to me. But at least it's it's the most powerful
of the stored procedure languages, so I just say if I'm living in Postgres
land, then be like the Postgresers. And if I'm going to make a stored
procedure, do what the Postgres people do because no one really
wants to a TCL TK, and it's not going to help you all that much. Right? So this is just like a CREATE TABLE,
but it's actually creating a function which is kind of expanding your
database like when it creates a function. It makes a little space. I mean it creates a table, it makes a little
space for that table somewhere on the disk. Now we're going to stick
somewhere a function that can be pulled up and loaded up. The next thing that we do is we
actually create the trigger. Now what we're saying is this is kind of like
when an update statement happens, i.e., before an update on the table fav, for each row that is about to be updated, run
that row through this little trigger. So if there's one row, it's going to come
in here and it's going to have its updated_at then it goes back and then if there's
a second row it's going to come in. So remember update statements with
WHERE clauses could do many rows. So that's why it's for each row this update statement is going to
change, execute this trigger, which allows us to here comes
the row to the database jump in front of it, tweak it, and then
let it continue back into the database. So now when we say set howmuch
equals how muchplus 1, implicitly updated_at is set to NOW. And so like I said, stored procedures
can be very simple or very complex. I tend to use them for
very specific reasons. This seems like to me a good reason
because I just don't want to say updated_at equals NOW on every single
update statement because I like it. So up next. I'm going to try to pull a lot
of these ideas together and do a demo of reading and parsing files and
actually computing primary keys and using sub-selects and
making database administrators crazy.