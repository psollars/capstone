So here's something that you can just try. So go have coffee with a really good
person in databases and sit down. And basically say to that person, say,
I'm kind of a beginner in databases and I just learned this great technique, and
for me it really makes databases great. I love sub-queries. They are awesome. I can really express what I want so nice. And then just watch what they say. Probably you'll see that it's like in
cartoons where they start to get red and steam will come out of their ears.
"Sub-queries, what do you mean?" So let me talk to you about. First I'll tell you what
sub-queries are and I'll explain to you why they make database
administrators so freaked out and angry. Most because they went to training
that said sub-queries are evil. Here's a key though that
you got to be careful. If you're doing data mining, certain things
that are bad in online systems are not necessarily bad in data mining. because data mining is about
convenience, and if it only takes you five seconds instead
of one second, that's no big deal. But if you're in an online system and it
takes you five seconds versus one second, and there's a million people doing it, that is a big deal. Okay, so basically what is a sub-query? It is really a query within a query
that allows you to replace a value or a set of values inside of a query
with another SELECT statement. So we go find this account record that has
ed in it and we find out that that's 7. And so we can say, go find content
from comment where id account = 7. And sort of to do this, unless we used
a join, but let's ignore that for the moment. To do this you sort of
have to run two queries. You have to do this, then get the results
of this, and then feed that in. And so maybe you're writing Python code or
something that is running a query, looking at it. Or maybe you're typing it yourself and
then you cut and paste that number and put it into the second query, right? So somehow that number 7
moves from the first query, the result of the first query,
into the second query. Well wouldn't it be nice if we could just
do that all in one statement, and you can. And so you just put this parentheses and
then you throw in a SELECT. Now this particular SELECT is selecting to
get a number, because there's exactly one row that's going to make it. And it's where account_id equals
is expecting a number. And so it's like out comes the 7 and then these two things basically are then
equivalent as long as the number is 7. And it turns out that what if there's two
things that came back from the SELECT statement. There's actually an "in" here. There's another operator
that if this is a set, you can say WHERE account_id in SELECT
blah blah blah FROM WHERE blah blah blah. And so this might be 40 of
these things come back. And this WHERE clause is smart enough
because that's kind of like an array of IDs at that point. And the WHERE clause is smart enough
to see if it's in there, right? So this is a very convenient way of
expressing a whole bunch of things really. And if performance doesn't matter, sometimes pretty is more
important than performant. Although most database administrators will
encourage you to find a way to do what you want it to do without using a sub-query
and this is the reason why. The reason why is because when
you send a query to the database, whatever that query is, and
I sort of draw this with my hand and say, here we send this query and
the database is like so smart. It knows about all these things and knows
where the data is, and it has indexes, and it's doing what's called optimization. And later we'll talk a lot more
about performance optimization, but it's able to take the abstract
question of please get me this stuff. Sort it this way, order it this way,
group it this way, distinct, whatever. But I don't care how you do it. The problem with sub-queries is you're
kind of telling the database how to do it. What you're saying is I have two things
I want done and you have got to stop, you can optimize this part, and
make this really efficient. But then that part has got to produce
some output, and that becomes input, and then you can optimize this part,
right? And so the database administrators
are like, that's two queries. It's as if you did two queries. It's actually better than doing two
queries because you don't have to go from your Python code or
your web server to the database twice. And so it's actually better than two
queries, but it becomes a slower query. And one of the problems database
administrators don't like is slow queries in general. So they might say, no, you slow down because you're such a bad
designer that you're doing sub-queries. You go ahead and just do the two queries. And I as the database see two more
optimizable queries among the thousands and thousands of queries I'm getting
per minute, or per hour, or whatever. And so it produces the sort of, stops the optimization analysis
from the outside to the inside. But I'll be honest, I mean,
that's only, so it has to do everything inside this parentheses
before it can start looking at this. And so it it sort of sees this
as one optimization, runs this, gets the result, and
then sees that as another optimization. And who knows, database is an abstraction. This is just an expression of
what we're asking for, and the result could come in any order as long
as we got the same result no matter how the database tried to do it. It's just for now databases have chosen
to treat that inner select as a select that reads from the database and
writes into like a temporary table. And then the outer select kind of reads
from the temporary table and then and then all the other tables. So this second select you'd think
there's sort of two tables involved. There is this comment table,
oops, comment table, and then there is this table
created by the inner select. And again, that's what
the database administrators don't like is that temporary
table that's sort of part and parcel of how these sub-queries
are supposed to work. So that's the basics of sub-queries. If I go back to the HAVING clause, and
remember the HAVING is kind of the second WHERE clause that happens
after the GROUP BY. So the WHERE clause happens before
the GROUP BY, then you have the GROUP BY, and then you have the HAVING
clause which is a WHERE clause. And so you can only look at this
COUNT in the HAVING clause. You can't do it in the WHERE clause
because the WHERE clause is what helps produce this COUNT value. That's from before. Now if we didn't have HAVING, you'd be like
oh, that's pretty bad. And I think most databases do have HAVING. This actually is really, once you understand it,
I think this is very elegant. But let's just say you didn't have HAVING,
you could do this with sub-queries and some unhappiness on the part of your
database administrator using this SQL. So the sub-query, remember, is
you start with parentheses. So we have kind of an outer select and
an inner select. The inner select happens first. And then we're kind of making
a temporary table. It's like, stop everything, run
the inner select, take those results and put them in a table. And those tables have columns
on top of them, right? And so this SELECT COUNT
abbrev FROM WHERE GROUP BY, well then that produces a little table. And this temporary table we're
going to call zap temporarily. Then from that from that inner
table when that work is done, it's going to select count and
abbrev, right? Now the count, the reduction,
the distinct, the group by, that all happened in the inner query. So it's a rather small table. But now we're going to select count and
abbrev from that temporary table with a WHERE clause that says where
count is greater than 10. So it's the same thing that's
having happening in happen. I mean, happening in HAVING,
right, in that it does it and then does another thing. This is a lot cleaner and there's a chance
that the database might be able to optimize this because we're doing a better
job of expressing what we really want. because here we're kind of expressing
procedurally, do this first, make a temporary table, and do the next thing
based on reading the temporary table. So we're kind of making it be steps and we're saying do it in order which
means it's harder for it to optimize. Whereas this could be optimized, we don't
know if it's going to be optimized but by not using a sub-query we have given
the database potential to optimize it. And so that's why database administrators
would rather you write this line than the sub-query line. Because maybe they can look at this and
they can find something inside the database that they
can make this go faster. But then they can't do something inside
the database to make this go faster. And so that that amazingness that is
the database, the database administrator can be part of that amazingness because
they can do things like add indexes, change indexes, recreate this or
that, or remove data around it. There are things they can do behind the
abstraction that make these queries run faster. And a more abstract query like this one
has a better chance of being optimized with the help of your database
administrator than this one. And so
that's kind of why they don't like them. So the next thing we're going
to talk about is concurrency. Concurrency really only matters if
you're kind of an online system and these transactions, like banking
transactions, are coming at the same time. But it's still an important concept
in case you're going to run into it. And that's we're going to talk about next.