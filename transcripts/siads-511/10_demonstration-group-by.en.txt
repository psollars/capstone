Welcome to another
walkthrough for Postgres. In this one, we are going to talk about GROUP BY and
how GROUP BY works. And GROUP BY is related to
DISTINCT in that both GROUP BY and DISTINCT in effect
create a record set and then post-process
that record set. DISTINCT is really simple, it throws things away. And for this one, instead of making yet another little data set
that's hard to keep track of, I'm just going to play with
the built-in time zones. So there are a whole
bunch of time zones. This pg_timezone_names
is a table that's sort of a virtual table that all the different time
zones that you can do. So it's got a name, abbreviation, the offset from UTC, and whether or not it's
Daylight Savings Time or not. So we've already talked
about SELECT COUNT star. There's 591 rows in
the pg_timezone_names. And we can also use a
SELECT DISTINCT, which is something we just
got done talking about. Which basically is reducing the vertical replication
in the is_dst. So you see there's just
either true or false, and so if we just do
a SELECT DISTINCT, you'll see that there's two
rows that are distinct. There's only a false
row and a true row, so the SELECT DISTINCT
showed me that. But probably I should
just say SELECT is_ist FROM pg _timezone_names
LIMIT 20, just for yucks. Now you'll see that if you don't say DISTINCT, oh, what did I do? is_dst, not is_ist. SELECT is_dst FROM
pg_timeszone _names LIMIT 20. Let me type it right,
is_dst. There we go. So you see how this
vertical replication, right? And DISTINCT just sort of squeezes out
that vertical replication. And again, it's looking at the rows. If I had added something to that, if I added something to it, the DISTINCT would
not just be is_dst, okay? We just talked about DISTINCT, so I'm not going to talk
about DISTINCT again. So here this SELECT COUNT is_dst. Let's take a look at
this particular one. So the idea here is this is pretty much like a
DISTINCT on is_dst, but in a sense as
the duplicate rows are being thrown away,
they're being counted. So SELECT COUNT is_dst and is_dst FROM pg_timezone
GROUP BY is_dst. So that basically says
this is kind of like a DISTINCT, but it's a grouping. So it groups all of the
f-rows together and then all the t-rows together
and then counts them and gives them back to us.
Okay? So that's the
essence of GROUP BY. Now I'll have some
more complex examples, but it's really
important that you have this basic example understood, right? Take a bunch of rows,
group them together by the distinct values of
is_dst, and then count them. And that's what this is showing us. But we can do some more things, right? We can do things like, we can do the same thing for
the abbreviation. Here's all the abbreviations
and the count of the different abbreviations
that are being used like EST for
Eastern Standard Time. There's a whole bunch of those. So that's another one. Now, you can have a WHERE clause. So let's look at this one. Make this one really
wide. There we go. You can have a WHERE clause, GROUP BY abbrev right here. So I can say this. Let me just run that one. So we have a WHERE clause and this WHERE clause affects the things that
participate in the count. So it's going to
calculate this count, but it's going to do
this is_dst equals true, right? Okay. And so that WHERE clause sort of filtered the records before
it did the GROUP BY, okay? Now the problem is
we might want to filter based on this count, and so that's what
the HAVING clause is. So the HAVING clause, the WHERE clause is
filter the records, pass them into the
GROUP BY process, and then the HAVING clause makes it so that we can
do it afterwards. So now we can say
WHERE COUNT abbrev. Now the key is as you got
to be pretty careful, you can't just put any old
thing in HAVING here. It's got to be one of the
things in the selected rows. So there were no
that WHERE dst is t, GROUP BY abbrev HAVING
COUNT more than 10. I think that if I made that
false, I might get more. Yeah, I got more. So there's not a lot of Daylight
Savings Times in there. A lot of false Daylight
Savings Times. So you'll see that. But again, the WHERE happens
before the GROUP BY, and that's why it's
this is the order here, it happened with a WHERE clause, and there's a GROUP BY clause, and then there's a HAVING clause. And just HAVING allows you to sort of post-process the
results of the GROUP BY, right? I think it's really
quite awesome. I mean, it may seem
like a silly thing, but believe me, it would
be difficult without it. So here we're just going to
count the abbreviations, and look for the ones
that are more than 10. And so that shows
You could also then, I would like to order this by the count of the
abbreviations descending. So we'll do that. Right? So these are the most common
abbreviations now, 43, 38. Right on down.
That's quite nice. There's only 12 of them
that have more than 10, abbreviations that are
used more than 10 times. And so this is a sub-query, and we'll talk about
sub-queries coming up next. So I hope this whole SELECT
DISTINCT was useful to you. I mean this GROUP BY
is useful to you. And then coming up, we're going to talk a little bit
about sub-queries.